#!/bin/sh
#
# General purpose build script for zopen community ports - https://github.com/zopencommunity
#
# ZOPEN_BUILD_LINE must be defined to either STABLE or DEV. This indicates the type of package to build
#
# For more details, see the help which you can get by issuing:
# zopen-build -h
#
# Copyright (C) 2023 zopen community.
#

#
# All zopen-* scripts MUST start with this code to maintain consistency.
#
setupMyself()
{
  ME=$(basename $0)
  MYDIR="$(cd "$(dirname "$0")" > /dev/null 2>&1 && pwd -P)"
  INCDIR="${MYDIR}/../include"
  if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
    echo "Internal Error. Unable to find common.sh file to source." >&2
    exit 8
  fi
  . "${INCDIR}/common.sh"
}
setupMyself

printEnvVar()
{
  echo "User-Provided environment variables:

Required:
  ZOPEN_BUILD_LINE    Specify the default build line, either 'DEV' or 'STABLE'
  ZOPEN_CATEGORIES    Specify a space-delimited list of applicable categories.
                      Valid categories:
                      ('${ZOPEN_VALID_CATEGORIES}')
  ZOPEN_DEV_DEPS      Required IF ZOPEN_BUILD_LINE='DEV'.
                      Specify the dev build dependencies
  ZOPEN_DEV_URL       Required IF ZOPEN_BUILD_LINE='DEV'. Specify the dev
                      build URL (either git or tarball).
  ZOPEN_STABLE_DEPS   Required IF ZOPEN_BUILD_LINE='STABLE'.
                      Specify the stable build dependencies.
  ZOPEN_STABLE_URL    Required IF ZOPEN_BUILD_LINE='STABLE'. Specify the
                      stable build URL (either git or tarball).

Optional:
  ZOPEN_EXTRA_CFLAGS    C compiler flags to append to CFLAGS (defaults to '').
  ZOPEN_EXTRA_CPPFLAGS  C,C++ pre-processor flags to append to CPPFLAGS.
                        (defaults to '')
  ZOPEN_EXTRA_CXXFLAGS  C++ compiler flags to append to CXXFLAGS.
                        (defaults to '')
  ZOPEN_EXTRA_LDFLAGS   C,C++ linker flags to append to LDFLAGS.
                        (defaults to '')
  ZOPEN_EXTRA_LIBS      C,C++ libraries to append to LIBS. (defaults to '')

  ZOPEN_BOOTSTRAP             Bootstrap program to run. If skip is specified,
                              no bootstrap step is performed.
                              (defaults to '${ZOPEN_BOOTSTRAPD}')
  ZOPEN_BOOTSTRAP_OPTS        Options to pass to bootstrap program.
                              (defaults to '${ZOPEN_BOOTSTRAP_OPTSD}')
  ZOPEN_CHECK                 Check program to run. If skip is specified,
                              no check step is performed.
                              (defaults to '${ZOPEN_CHECKD}')
  ZOPEN_CHECK_MINIMAL         Check program will not be passed CFLAGS, LDFLAGS,
                              CPPFLAGS options but will get them from env vars.
  ZOPEN_CHECK_OPTS            Options to pass to check program.
                              (defaults to '${ZOPEN_CHECK_OPTSD}')
  ZOPEN_CHECK_TIMEOUT         Timeout limit in seconds for the check program.
                              (defaults to '${ZOPEN_CHECK_TIMEOUTD}')
  ZOPEN_CLEAN                 Clean up program to run.
                              (defaults to '${ZOPEN_CLEAND}')
  ZOPEN_CLEAN_OPTS            Options to pass to clean up  program.
                              (defaults to '${ZOPEN_CLEAN_OPTSD}')
  ZOPEN_CONFIGURE             Configuration program to run. If skip is
                              specified, no configuration step is performed.
                              (defaults to '${ZOPEN_CONFIGURED}')
  ZOPEN_CONFIGURE_MINIMAL     Configuration program will not be passed CFLAGS,
                              LDFLAGS, CPPFLAGS options but will get them from
                              env vars.
  ZOPEN_CONFIGURE_OPTS        Options to pass to configuration program.
                              (defaults to '--prefix=\${ZOPEN_INSTALL_DIR}')
  ZOPEN_EXTRA_CONFIGURE_OPTS  Extra configure options to pass to configuration
                              program. (defaults to '')
  ZOPEN_INSTALL               Installation program to run. If skip is specified,
                              no installation step is performed.
                              (defaults to '${ZOPEN_INSTALLD}')
  ZOPEN_INSTALL_OPTS          Options to pass to installation program.
                              (defaults to '${ZOPEN_INSTALL_OPTSD}')
  ZOPEN_MAKE                  Build program to run. If skip is specified,
                              no build step is performed.
                              (defaults to '${ZOPEN_MAKED}')
  ZOPEN_MAKE_MINIMAL          Build program will not be passed CFLAGS, LDFLAGS,
                              CPPFLAGS options but will get them from env vars.
  ZOPEN_MAKE_OPTS             Options to pass to build program.
                              (defaults to '-j\${ZOPEN_NUM_JOBS}')
  ZOPEN_PATCH_DIR             Specify directory from which patches should be applied.

Optional settings for installation:
  ZOPEN_RUNTIME_DEPS          Runtime z/OS Open Tool dependencies to be installed
                              alongside the tool.
  ZOPEN_SYSTEM_PREREQ         System prerequisites, supply the name of the prereq
                              scripts under $ZOPEN_SYSTEM_PREREQ_SCRIPT

Restricted Usage - only set in ports if necessary
  ZOPEN_DONT_ADD_ZOSLIB_DEP   Set to avoid adding zoslib as a dependency.

Restricted Usage - only SET by metaport, otherwise READ ONLY:
  ZOPEN_INSTALL_DIR   Installation directory to pass to configuration.
                      (defaults to '\${ZOPEN_PKGINSTALL}/<pkg>/<pkg>')
  ZOPEN_NUM_JOBS      Number of jobs that can be run in parallel
                      (defaults to half the CPUs on the system)

Restricted Usage (clang):
  ZOPEN_CFLAGS        C compiler flags. (default set by dependency)
  ZOPEN_CPPFLAGS      C/C++ pre-processor flags. (default set by dependency)
  ZOPEN_CXXFLAGS      C++ compiler flags. (default set by dependency)
  ZOPEN_LDFLAGS       C/C++ linker flags. (default set by dependency)

Restricted Usage (phpport):
  ZOPEN_GIT_SETUP     Specify whether git files should be added to a local
                      repo or if this will be done manually. (defaults to Y)

Restricted Usage (tclport):
  ZOPEN_SRC_DIR       Specify a relative source directory to cd to for
                      bootstrap, configure, build, check, install.
                      (defaults to '.')

Restricted Usage (meta):
  ZOPEN_IMAGE_DOCKERFILE_NAME     Dockerfile name. (default: Dockerfile)
  ZOPEN_IMAGE_DOCKER_NAME         Docker/podman tool name. (default: podman)
  ZOPEN_IMAGE_REGISTRY            Docker image registry to an OCI image to
                                  (use with --oci option)
  ZOPEN_IMAGE_REGISTRY_ID         The ID to authenticate to the Docker image
                                  registry. (use with --oci option)
  ZOPEN_IMAGE_REGISTRY_KEY_FILE   The file containing authentication key to the
                                  Docker image registry. (use with --oci option)
  ZOPEN_LOG_DIR                   The directory to store build logs.
                                  (defaults to '${ZOPEN_ROOT}/log')
  ZOPEN_SHELL                     Specify an alternate shell to use if -s
                                  option specified. (defaults to /bin/sh)

Being reworked to move to common ZOPEN_xxx_GIT_REFS:
  ZOPEN_DEV_BRANCH      The branch that the git repo should checkout.
                        (default is repo default)
  ZOPEN_DEV_TAG         The tag that the git repo should checkout as a branch.
                        (optional)
  ZOPEN_STABLE_BRANCH   The branch that the stable repo should checkout.
                        (default is repo default)
  ZOPEN_STABLE_TAG      The tag that the git repo should checkout as a branch.
                        (optional)

Currently unused:
  ZOPEN_DEV_TYPE        The type of package to download. Valid types are
                        TARBALL, BARE and GIT.
  ZOPEN_STABLE_TYPE     The type of package to download. Valid types are
                        TARBALL, BARE and GIT.

Deprecated:
  ZOPEN_CC              C compiler. (default set by dependency)
  ZOPEN_CXX             C++ compiler. (default set by dependency)
  ZOPEN_DEPS            Alternate environment variable instead of
                        ZOPEN_TARBALL_DEPS or ZOPEN_GIT_DEPS.
  ZOPEN_GIT_BRANCH      The branch that the git repo should checkout.
  ZOPEN_GIT_DEPS        Space-delimited set of source packages this tarball
                        package depends on to build.
                        (required if ZOPEN_TYPE=GIT)
  ZOPEN_GIT_TAG         The tag that the git repo should checkout as a branch.
  ZOPEN_GIT_URL         The fully qualified URL that the git repo should be
                        cloned from. (required if ZOPEN_TYPE=GIT)
  ZOPEN_LIBS            C/C++ libraries (default set by dependency)
  ZOPEN_TARBALL_DEPS    Space-delimited set of source packages this git package
                        depends on to build. (required if ZOPEN_TYPE=TARBALL)
  ZOPEN_TARBALL_URL     The fully qualified URL that the tarball should be
                        downloaded from. (required if ZOPEN_TYPE=TARBALL)
  ZOPEN_TYPE            The type of package to download. Valid types are
                        TARBALL, BARE and GIT.
  ZOPEN_URL             Alternate environment variable instead of
                        ZOPEN_TARBALL_URL or ZOPEN_GIT_URL.
"
}

printFunctions()
{
  echo "User-Provided functions:

Required:
  zopen_check_results               This function runs after the 'check' step
                                    of the build and must print out expected
                                    and actual failures.
  zopen_get_version                 This function returns the version of the
                                    tool in accordance with semantic versioning.

Optional:
  zopen_append_to_env               This function runs as part of generation
                                    of the .env file. The output of the
                                    function is appended to .env.
  zopen_append_to_setup             This function runs as part of generation of
                                    the setup.sh file. The output of the
                                    function is appended to setup.sh.
  zopen_append_to_validate_install  This function runs as part of generation of
                                    the install_test.sh file. The output of the
                                    function is appended to install_test.sh
                                    script.
  zopen_install_caveats             This function is run post install. All stdout 
                                    messages are captured and added to the metadata.json
                                    as installation caveats.
  zopen_append_to_zoslib_env        This function runs as part of generation of
                                    the C function zoslib_env_hook, which can
                                    be used to set environment variables before
                                    main is run.
  zopen_init                        This function runs after code is downloaded
                                    and patched but before the code is built.
  zopen_post_buildenv               This function runs after the 'buildenv' is
                                    processed.
  zopen_post_install                This function runs after the 'install' step
                                    of the build is run.
  zopen_pre_build                   This function runs before the 'make' step
                                    of the build is run.
  zopen_pre_check                   This function runs before the 'check' step
                                    of the build is run.
  zopen_pre_configure               This function runs before the 'configure'
                                    step of the build is run.
  zopen_pre_install                 This function runs before the 'install'
                                    step of the build is run.
  zopen_pre_patch                   This function runs before the 'patch' step
                                    of the build is run.
  zopen_pre_terminate               This function runs before 'zopen build'
                                    terminates.
  "
}

printSeeAlso()
{
  echo "SEE ALSO:
  zopen(1)
  zopen-alt(1)
  zopen-init(1)
  zopen-install(1)
  zopen-list(1)
  zopen-remove(1)
  "
}

TMP_FIFO_PIPE="${zopen_tmp_dir}/${LOGNAME}.pipe"
ZOPEN_TEMP_C_FILE="${zopen_tmp_dir}/${LOGNAME}.c"

setDefaultBuild()
{
  if [ ! -z "${ZOPEN_BUILD_LINE_OPT}" ]; then
    ZOPEN_BUILD_LINE=$(echo "${ZOPEN_BUILD_LINE_OPT}" | tr '[a-z]' '[A-Z]')
  else
    ZOPEN_BUILD_LINE=$(echo "${ZOPEN_BUILD_LINE}" | tr '[a-z]' '[A-Z]')
  fi

  if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
    printVerbose "Setting build to ${ZOPEN_BUILD_LINE}"
  fi
}

setDefaults()
{
  export ZOPEN_BOOTSTRAPD="./bootstrap"
  export ZOPEN_BOOTSTRAP_OPTSD=""
  export ZOPEN_CONFIGURED="./configure"
  export ZOPEN_MAKED="make"
  export ZOPEN_CHECKD="make"
  export ZOPEN_CHECK_OPTSD="check"
  export ZOPEN_CHECK_TIMEOUTD="12600" # 3.5 hours
  export ZOPEN_INSTALLD="make"
  export ZOPEN_INSTALL_OPTSD="install"
  export ZOPEN_CLEAND="make"
  export ZOPEN_CLEAN_OPTSD="clean"
  if [ -z "${ZOPEN_IMAGE_DOCKERFILE_NAME}" ]; then
    export ZOPEN_IMAGE_DOCKERFILE_NAME="Dockerfile"
  fi
  if [ -z "${ZOPEN_IMAGE_DOCKER_NAME}" ]; then
    export ZOPEN_IMAGE_DOCKER_NAME="podman"
  fi
  export ZOPEN_TEST_STATUS_ALL_PASSED=0
  export ZOPEN_TEST_STATUS_MOST_PASSED=1
  export ZOPEN_TEST_STATUS_SOME_PASSED=2
  export ZOPEN_TEST_STATUS_NONE_PASSED=3
  export ZOPEN_TEST_STATUS_ERROR=4
  export ZOPEN_TEST_STATUS_SKIPPED=5
  # Define the valid categories
  export ZOPEN_VALID_CATEGORIES="$(cat ${MYDIR}/../data/tool_categories.txt)"
  unset ZOPEN_CPPFLAGS
  unset ZOPEN_CFLAGS
  unset ZOPEN_CXXFLAGS
  unset ZOPEN_LDFLAGS
  unset ZOPEN_LIBS
  unset ZOPEN_EXTRA_CPPFLAGS
  unset ZOPEN_EXTRA_CFLAGS
  unset ZOPEN_EXTRA_CXXFLAGS
  unset ZOPEN_EXTRA_LDFLAGS
  unset ZOPEN_EXTRA_LIBS
  return 0
}

printSyntax()
{
  args=$*
  cat << HELPDOC
${ME} is a general purpose build script to be used with the
zopen community ports.

Usage: ${ME} [OPTION]...

Option:
  --build LINE          LINE may be dev or stable. This is the build line
                        to build off of.
  --buildtype TYPE      TYPE may be release or debug.  The default is release.
  -c, --clean           Deletes all of the build output and forces
                        reconfigure with next build.
  --comp COMP           COMP may be xlclang, clang, go, java
                        python. The default is clang.
  -e ENV_FILE           source ENV_FILE instead of buildenv to establish
                        build environment.
  --instrument          instruments the application with option -finstrument-functions (clang only)
  -f, --force-rebuild   forces a rebuild, including running bootstrap
                        and configure again.
  --forcepatchapply     force apply the patches, where rejected patches are
                        placed into a corresponding file of the same name,
                        with the .rej extension.
  -g, --get-source      get the source and apply patch without building.
  -gp, --generate-pax   generate a pax.Z file based on the install contents.
  -h, --help, -?        print this information.
  --no-set-active       do not change the pinned version.
  --no-install-deps     do not install project's runtime dependencies.
  --oci                 build and publish an OCI image to \$ZOPEN_IMAGE_REGISTRY.
  -s                    exec a shell before running configure. Useful when
                        manually building ports.
  --sign-pax, -sp       This option signs the pax file.
			ZOPEN_GPG_SECRET_KEY_FILE, ZOPEN_GPG_SECRET_KEY_PASSPHRASE_FILE
                        and ZOPEN_GPG_PUBLIC_KEY_FILE must be set for signing the file.
  -v                    run in verbose mode.
  -vv                   run in very verbose mode (sets environment variables
                        V=1 and VERBOSE=1).
  -u, --upgradedeps     upgrade all dependencies by running zopen install.

The specifics of how the tool works can be controlled through environment
variables. The only environment variables you _must_ specify are to tell
${ME} where the source is, and in what format type the source is stored.
By default, the environment variables are defined in a file named buildenv
in the root directory of the [PACKAGE]port github repository.

To see a fully functioning zopen community sample port see:
https://github.com/zopencommunity/zotsampleport

HELPDOC

printEnvVar
printFunctions
printSeeAlso
}

processOptions()
{
  args=$*
  verbose=false
  publishOCI=false
  skipcheck=false
  buildInReleaseMode=true
  startShell=false
  cleanupBuild=false
  forceRebuild=false
  freshBuild=false
  buildEnvFile="./buildenv"
  getSourceOnly=false
  generatePax=false
  setActive=true
  signPax=false
  forcePatchApply=false
  depsPath="${ZOPEN_PKGINSTALL}"
  forceUpgradeDeps=false
  noInstallRuntimeDeps=false
  instrument=false
  depsDepth=2
  while [ $# -gt 0 ]; do
    case $1 in
    "-h" | "--help" | "-?")
      trap - EXIT
      printSyntax "${args}"
      exit 0
      ;;
    "--version")
      trap - EXIT
      zopen-version ${ME}
      exit 0
      ;;
    "-v" | "--verbose")
      verbose=true
      ;;
    "-vv" | "--vv" | "--veryverbose")
      export V=1
      export VERBOSE=1
      verbose=true
      ;;
    "-u" | "--upgradeDeps")
      forceUpgradeDeps=true
      ;;
    "--forcepatchapply")
      forcePatchApply=true
      ;;
    "--no-install-deps")
      noInstallRuntimeDeps=true
      ;;
    "--instrument")
      instrument=true
      ;;
    "-buildtype" | "--buildtype" | "-b")
      shift
      btype=$(echo "$1" | awk '{print toupper($0)}')
      if [ "${btype}" = "DEBUG" ]; then
        buildInReleaseMode=false
      fi
      ;;
    "--deps-depth")
      shift
      depsDepth=$1
      ;;
    "-comp" | "--comp")
      shift
      ZOPEN_COMP=$1 # We will uppercase this later
      ;;
    "-build" | "--build")
      shift
      ZOPEN_BUILD_LINE_OPT=$1
      ;;
    "-oci" | "--oci")
      publishOCI=true
      ;;
    "-sc" | "--skipcheck")
      skipcheck=true
      ;;
    "-d" | "--depspath")
      shift
      depsPath="${1}|${depsPath}"
      ;;
    "--no-set-active")
      setActive=false # Install package as normal but keep existing installation as active
      ;;
    "-e" | "--env")
      shift
      buildEnvFile=$1
      ;;
    "-c" | "--clean")
      cleanupBuild=true
      ;;
    "-f" | "--force-rebuild")
      forceRebuild=true
      ;;
    "-g" | "--get-source")
      getSourceOnly=true
      ;;
    "-gp" | "--generate-pax")
      generatePax=true
      ;;
    "-s" | "--shell")
      startShell=true
      ;;
    "-sp" | "--sign-pax")
      signPax=true
      ;;
    *)
      printError "Unknown option ${1} specified"
      ;;
    esac
    shift
  done
}

signPaxFile()
{
  # Paths to your files
  printHeader "Signing pax file ${paxFileName}"
  printHeader "Signing pax file ${paxFileName}"
  PRIVATE_KEY="${ZOPEN_GPG_SECRET_KEY_FILE}"
  PASSPHRASE_FILE="${ZOPEN_GPG_SECRET_KEY_PASSPHRASE_FILE}"
  FILE_TO_SIGN="${paxFileName}"
  OUTPUT_SIGNATURE="${paxFileName}.asc"

  # Create a temporary directory for GPG keyring
  TMP_GPG_DIR="$zopen_tmp_dir/tmp_gpg"
  mkdir -p "$TMP_GPG_DIR"
  chmod u+w "$TMP_GPG_DIR"

  # Import the private key into the specified keyring files
  printInfo "Importing private key..."
  gpg --no-default-keyring --keyring "$TMP_GPG_DIR/pubring.kbx" --secret-keyring "$TMP_GPG_DIR/secring.gpg" --batch --yes --import "$PRIVATE_KEY"
  if [ $? -ne 0 ]; then
      extractPax=false
      printError "Importing private key failed. Signing aborted."
  fi

  # Verify that the key was imported successfully
  printInfo "Checking if secret key is imported..."
  gpg --no-default-keyring --keyring "$TMP_GPG_DIR/pubring.kbx" --secret-keyring "$TMP_GPG_DIR/secring.gpg" --list-secret-keys
  if [ $? -ne 0 ]; then
      extractPax=false
      printError "No secret key found. Signing aborted."
  fi

  # Sign the file
  printInfo "Signing the file..."

  gpg --armor --no-default-keyring --keyring "$TMP_GPG_DIR/pubring.kbx" --batch --verbose --pinentry-mode loopback --passphrase-file "$PASSPHRASE_FILE" --output "$OUTPUT_SIGNATURE" --detach-sig "$FILE_TO_SIGN"

  if [ $? -ne 0 ]; then
      extractPax=false
      printError "Error signing the file."
  else
      SIGNATURE=$(jq -Rs . < ${OUTPUT_SIGNATURE})
      printInfo "File signed successfully. Signature saved to $OUTPUT_SIGNATURE."
  fi

  # Clean up the temporary keyring directory
  [ -e "${TMP_GPG_DIR}" ] && rm -rf "${TMP_GPG_DIR}"
}


loadBuildEnv()
{
  if [ ! -r ${buildEnvFile} ]; then
    printError "Build environment file '${buildEnvFile}' does not exist or is not readable. Use zopen generate to create a buildenv file."
  fi

  # Indicates to .env script that we're in zopen build
  export ZOPEN_IN_ZOPEN_BUILD="$LOGNAME.$$.$RANDOM"

  . ${buildEnvFile}

  setDefaultBuild


  if command -V "zopen_post_buildenv" > /dev/null 2>&1; then
    printVerbose "Running zopen_post_buildenv"
    zopen_post_buildenv
  fi
}

checkEnv()
{
  printHeader "Checking environment configuration"

  if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
    if [ "${ZOPEN_BUILD_LINE}x" = "DEVx" ]; then
      if [ -z "${ZOPEN_DEV_DEPS}" ]; then
        printError "Building from dev, but ZOPEN_DEV_DEPS not specified"
      fi
      ZOPEN_DEPS="${ZOPEN_DEV_DEPS}"
      if [ -z "${ZOPEN_DEV_URL}" ]; then
        printError "Building from dev, but ZOPEN_DEV_URL not specified"
      fi
      ZOPEN_URL="${ZOPEN_DEV_URL}"
      if [ ! -z "${ZOPEN_DEV_BRANCH}" ]; then
        export ZOPEN_GIT_BRANCH="${ZOPEN_DEV_BRANCH}"
      fi
      if [ ! -z "${ZOPEN_DEV_TAG}" ]; then
        export ZOPEN_GIT_TAG="${ZOPEN_DEV_TAG}"
      fi
      if [ ! -z "${ZOPEN_DEV_TYPE}" ]; then
        export ZOPEN_TYPE="${ZOPEN_DEV_TYPE}"
      else
        extension="${ZOPEN_URL##*.}"
        if [ "${extension}" = "git" ]; then
          ZOPEN_TYPE="GIT"
        else
          ZOPEN_TYPE="TARBALL"
        fi
      fi
    elif [ "${ZOPEN_BUILD_LINE}x" = "STABLEx" ]; then
      if [ -z "${ZOPEN_STABLE_DEPS}" ]; then
        printError "Building from stable, but ZOPEN_STABLE_DEPS not specified"
      fi
      ZOPEN_DEPS="${ZOPEN_STABLE_DEPS}"
      if [ -z "${ZOPEN_STABLE_URL}" ]; then
        printError "Building from stable, but ZOPEN_STABLE_URL not specified"
      fi
      ZOPEN_URL="${ZOPEN_STABLE_URL}"
      if [ ! -z "${ZOPEN_STABLE_BRANCH}" ]; then
        export ZOPEN_GIT_BRANCH="${ZOPEN_STABLE_BRANCH}"
      fi
      if [ ! -z "${ZOPEN_STABLE_TAG}" ]; then
        export ZOPEN_GIT_TAG="${ZOPEN_STABLE_TAG}"
      fi
      if [ ! -z "${ZOPEN_STABLE_TYPE}" ]; then
        export ZOPEN_TYPE="${ZOPEN_STABLE_TYPE}"
      else
        extension="${ZOPEN_URL##*.}"
        if [ "${extension}" = "git" ]; then
          ZOPEN_TYPE="GIT"
        else
          ZOPEN_TYPE="TARBALL"
        fi
      fi
    else
      printError "Unrecognized build line ${ZOPEN_BUILD_LINE}"
    fi
  else
    if [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
      if [ ! -z "${ZOPEN_TARBALL_URL}" ]; then
        export ZOPEN_URL="${ZOPEN_TARBALL_URL}"
      fi
      if [ ! -z "${ZOPEN_TARBALL_DEPS}" ]; then
        export ZOPEN_DEPS="${ZOPEN_TARBALL_DEPS}"
      fi
      printHeader "Using stable environment"
    elif [ "${ZOPEN_TYPE}x" = "GITx" ]; then
      if [ ! -z "${ZOPEN_GIT_URL}" ]; then
        export ZOPEN_URL="${ZOPEN_GIT_URL}"
      fi
      if [ ! -z "${ZOPEN_GIT_DEPS}" ]; then
        export ZOPEN_DEPS="${ZOPEN_GIT_DEPS}"
      fi
      printHeader "Using dev environment"
    elif [ "${ZOPEN_TYPE}x" = "BAREx" ]; then
      printHeader "Using bare environment"
    else
      extension="${ZOPEN_URL##*.}"
      if [ "${extension}" = "git" ]; then
        ZOPEN_TYPE="GIT"
      else
        ZOPEN_TYPE="TARBALL"
      fi
    fi
  fi

  ZOPEN_INIT_CODE="zopen_init"
  ZOPEN_PRE_CHECK_CODE="zopen_pre_check"
  ZOPEN_APPEND_TO_ENV_CODE="zopen_append_to_env"
  ZOPEN_APPEND_TO_ZOSLIB_ENV_CODE="zopen_append_to_zoslib_env"
  ZOPEN_APPEND_TO_SETUP_CODE="zopen_append_to_setup"
  ZOPEN_APPEND_TO_VALIDATE_CODE="zopen_append_to_validate_install"
  ZOPEN_PRE_CONFIGURE_CODE="zopen_pre_configure"
  ZOPEN_PRE_BUILD_CODE="zopen_pre_build"
  ZOPEN_PRE_INSTALL_CODE="zopen_pre_install"
  ZOPEN_POST_INSTALL_CODE="zopen_post_install"
  ZOPEN_CHECK_RESULTS_CODE="zopen_check_results"
  ZOPEN_PRE_TERMINATE_CODE="zopen_pre_terminate"

  if ! command -V "${ZOPEN_CHECK_RESULTS_CODE}" > /dev/null 2>&1; then
    if [ "${ZOPEN_CHECK}x" != "skipx" ] && ! ${skipcheck}; then
      export ZOPEN_CHECK_RESULTS_CODE="${ZOPEN_ROOT}/portchk.sh"
      if ! [ -x "${ZOPEN_CHECK_RESULTS_CODE}" ]; then
        printError "zopen_check_results script needs to be provided to check the results."
      fi
    fi
  fi

  implicitDeps="sed git jq curl"

  if [ -z "${ZOPEN_COMP}" ]; then
    implicitDeps="${implicitDeps} check_clang"
  else
    # user specified, so normalize in lower case
    ZOPEN_COMP=$(echo "${ZOPEN_COMP}" | tr '[A-Z]' '[a-z]')
    if [ "${ZOPEN_COMP}x" != 'skipx' ]; then
      implicitDeps="${implicitDeps} check_${ZOPEN_COMP}"
    fi
  fi

  if [ -z "${ZOPEN_DONT_ADD_ZOSLIB_DEP}" ]; then
    # Add zoslib as an implicit library
    implicitDeps="${implicitDeps} zoslib"
  fi

  if [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
    if [ -z "${ZOPEN_URL}" ]; then
      printError "ZOPEN_STABLE_URL, ZOPEN_DEV_URL, ZOPEN_URL or ZOPEN_TARBALL_URL needs to be defined"
    fi
    if [ -z "${ZOPEN_DEPS}" ]; then
      printError "ZOPEN_STABLE_DEPS, ZOPEN_DEV_DEPS, ZOPEN_DEPS or ZOPEN_TARBALL_DEPS needs to be defined"
    fi
    implicitDeps="${implicitDeps} tar"
    ext=${ZOPEN_URL##*.}
    if [ "${ext}x" = "xzx" ]; then
      implicitDeps="${implicitDeps} xz"
    elif [ "${ext}x" = "gzx" -o "${ext}x" = "tgzx" ]; then
      implicitDeps="${implicitDeps} gzip"
    elif [ "${ext}x" = "bz2x" ]; then
      implicitDeps="${implicitDeps} bzip2"
    elif [ "${ext}x" = "zipx" ]; then
      implicitDeps="${implicitDeps} unzip"
    fi
    printVerbose "Implicitly adding tarball dependencies: ${implicitDeps}"
  elif [ "${ZOPEN_TYPE}x" = "GITx" ]; then
    if [ -z "${ZOPEN_URL}" ]; then
      printError "ZOPEN_STABLE_URL, ZOPEN_DEV_URL, ZOPEN_URL or ZOPEN_GIT_URL needs to be defined"
    fi
    if [ -z "${ZOPEN_DEPS}" ]; then
      printError "ZOPEN_STABLE_DEPS, ZOPEN_DEV_DEPS, ZOPEN_DEPS or ZOPEN_GIT_DEPS needs to be defined"
    fi
    implicitDeps="${implicitDeps}"
    printVerbose "Implicitly adding git dependencies: ${implicitDeps}"
  fi
  ZOPEN_DEPS="${implicitDeps} ${ZOPEN_DEPS}"

  ZOPEN_COMMIT_SHA="$(git rev-parse HEAD)"

  ZOPEN_CATEGORIES_LOWER=$(printf "%s" "$ZOPEN_CATEGORIES" | tr '[:upper:]' '[:lower:]')

  for category in $(echo ${ZOPEN_CATEGORIES_LOWER} | tr ' ' '\n' | sort -u); do
    if ! echo "${ZOPEN_VALID_CATEGORIES}" | tr ' ' '\n' | grep -q "^${category}$"; then
      printError "Invalid category specified in \$ZOPEN_CATEGORIES: ${category}"
    fi
  done

  ZOPEN_REMOTE_URL="$(git config --get remote.origin.url)"
  if [ -z "${ZOPEN_REMOTE_URL}" ]; then
    ZOPEN_REMOTE_URL="local"
  else
    if [ -n "$(echo "${ZOPEN_REMOTE_URL}" | grep '^git@')" ]; then
      ZOPEN_REMOTE_URL="${ZOPEN_REMOTE_URL#*:}"
      ZOPEN_REMOTE_URL="https://github.com/$ZOPEN_REMOTE_URL"
    fi

    ZOPEN_REMOTE_URL="${ZOPEN_REMOTE_URL%.git}"
  fi

  # Check for validity
  if [ -n  "${ZOPEN_SYSTEM_PREREQ}" ]; then
    . $ZOPEN_SYSTEM_PREREQ_SCRIPT
    echo "${ZOPEN_SYSTEM_PREREQ}" | xargs | tr ' ' '\n' | sort | while read prereq; do
      if ! command -V "${prereq}" >/dev/null 2>&1; then
        printError "ZOPEN_SYSTEM_PREREQ prereq \"${prereq}\" does not exist in \"$ZOPEN_SYSTEM_PREREQ_SCRIPT\""
      fi
    done
  fi 

}

setDepsEnv()
{
  deps="${ZOPEN_DEPS}"

  orig="${PWD}"
  # Filter out duplicate deps
  deps=$(echo "${deps}" | xargs | tr ' ' '\n' | sort -u)
  for dep in ${deps}; do
    printVerbose "Searching for dependency ${dep}"
    parseline=$(parseDeps ${dep})
    dep=$(echo ${parseline} | awk -F'|' '{print $1}')
    operator=$(echo ${parseline} | awk -F'|' '{print $2}')
    requestedMajor=$(echo ${parseline} | awk -F'|' '{print $3}')
    requestedMinor=$(echo ${parseline} | awk -F'|' '{print $4}')
    requestedPatch=$(echo ${parseline} | awk -F'|' '{print $5}')
    requestedSubrelease=$(echo ${parseline} | awk -F'|' '{print $6}')
    requestedVersion="${requestedMajor}.${requestedMinor}.${requestedPatch}.${requestedSubrelease}"
    foundDep=false
    for path in $(echo ${depsPath} | tr '|' '\n'); do
      if [ -r "${path}/${dep}/${dep}/.env" ]; then
        depdir="${path}/${dep}/${dep}"
        versionPath="${depdir}/.version"
        if [ -r "${versionPath}" ]; then
          version=$(cat "${versionPath}")
        fi
        # Avoid double sourcing the .env if we're forcing an upgrade on it
        if ! ${forceUpgradeDeps}; then
          if ! validateVersion "${version}" "${operator}" "${requestedVersion}" "${depdir}"; then
            continue
          fi

          printVerbose "Setting up ${depdir} dependency environment"
          cd "${depdir}" && . ./.env
          if [ $? -gt 0 ]; then
            printError "Failed to source ${depdir} .env"
          fi
        fi
        foundDep=true
        break
      fi
    done
    if ! ${foundDep} || ${forceUpgradeDeps}; then
      if ! ${forceUpgradeDeps}; then
        if [ -z "${operator}" ]; then
          printWarning "Dependency ${dep} not found. Downloading via zopen install"
        else
          printWarning "Dependency ${dep} ${operator} ${requestedVersion} not found. Downloading via zopen install"
        fi
      else
        printHeader "Upgrading dependency ${dep}. Installing via zopen install"
      fi
      path=${ZOPEN_PKGINSTALL} # Install location
      if ! runAndLog "PATH=\"${ZOPEN_OLD_PATH}\" ${MYDIR}/zopen-install --install-or-upgrade ${dep} -v -y"; then
        printError "zopen install command failed"
      fi
      depdir="${path}/${dep}/${dep}"
      printVerbose "Setting up upgraded ${depdir} dependency environment"
      cd "${depdir}" && . ./.env
      if [ $? -gt 0 ]; then
        printError "Failed to source ${depdir} .env"
      fi
      versionPath="${depdir}/.version"
      if [ -r "${versionPath}" ]; then
        version=$(cat "${versionPath}")
      fi
      if ! validateVersion "${version}" "${operator}" "${requestedVersion}" "${depdir}"; then
        printError "Dependency ${depdir} upgraded, but does not satisfy \"${operator}\" \"${requestedVersion}\""
      fi
    fi
  done
  cd "${orig}" || exit 99
}

setEnv()
{

  # Certificate information
  export SSL_CERT_FILE="${ZOPEN_CA}"
  export GIT_SSL_CAINFO="${ZOPEN_CA}"
  export CURL_CA_BUNDLE="${ZOPEN_CA}"

  initDefaultEnvironment
  setDepsEnv

  if ${instrument}; then
    if [ "${CC}" = "clang" ] || [ "${CC}" = "ibm-clang" ]; then
      instrumentOptions="-finstrument-functions"
    else
      printWarning "In order to instrument your application, you must build with clang."
    fi
  fi

  # Dependencies such as libraries may add flags
  export CPPFLAGS="${ZOPEN_CPPFLAGS} ${ZOPEN_EXTRA_CPPFLAGS}"
  export CFLAGS="${ZOPEN_CFLAGS} ${ZOPEN_EXTRA_CFLAGS} ${instrumentOptions}"
  export CXXFLAGS="${ZOPEN_CXXFLAGS} ${ZOPEN_EXTRA_CXXFLAGS} ${instrumentOptions}"
  export LDFLAGS="${ZOPEN_LDFLAGS} ${ZOPEN_EXTRA_LDFLAGS}"
  export LIBS="${ZOPEN_LIBS} ${ZOPEN_EXTRA_LIBS}"

  # For compatibility with the default 'make' /etc/startup.mk on z/OS
  export CCC="${CXX}"
  export CCCFLAGS="${CXXFLAGS}"

  # Some configure scripts act on *_FOR_BUILD flags
  export CC_FOR_BUILD="${CC}"
  export CXX_FOR_BUILD="${CXX}"
  export CPPFLAGS_FOR_BUILD="${CPPFLAGS}"
  export CFLAGS_FOR_BUILD="${CFLAGS}"
  export LDFLAGS_FOR_BUILD="${LDFLAGS}"
  export LIBS_FOR_BUILD="${LIBS}"

  if [ -z "${ZOPEN_NUM_JOBS}" ]; then
    ZOPEN_NUM_JOBS=$("${MYDIR}/numcpus.rexx")

    # Use half of the CPUs by default
    export ZOPEN_NUM_JOBS=$((ZOPEN_NUM_JOBS / 2))
  fi

  if [ ${ZOPEN_NUM_JOBS} -lt 1 ]; then
    export ZOPEN_NUM_JOBS=1
  fi

  if [ -z "${ZOPEN_BOOTSTRAP}" ]; then
    export ZOPEN_BOOTSTRAP="${ZOPEN_BOOTSTRAPD}"
  fi
  if [ -z "${ZOPEN_BOOTSTRAP_OPTS}" ]; then
    export ZOPEN_BOOTSTRAP_OPTS="${ZOPEN_BOOTSTRAP_OPTSD}"
  fi
  if [ -z "${ZOPEN_CONFIGURE}" ]; then
    export ZOPEN_CONFIGURE="${ZOPEN_CONFIGURED}"
  fi
  if [ -z "${ZOPEN_MAKE}" ]; then
    export ZOPEN_MAKE="${ZOPEN_MAKED}"
  fi
  if [ -z "${ZOPEN_MAKE_OPTS}" ]; then
    export ZOPEN_MAKE_OPTS="-j${ZOPEN_NUM_JOBS}"
  fi
  if [ -z "${ZOPEN_CHECK}" ]; then
    export ZOPEN_CHECK="${ZOPEN_CHECKD}"
  fi
  if [ -z "${ZOPEN_CHECK_TIMEOUT}" ]; then
    export ZOPEN_CHECK_TIMEOUT="${ZOPEN_CHECK_TIMEOUTD}"
  fi
  if [ -z "${ZOPEN_CHECK_OPTS}" ]; then
    export ZOPEN_CHECK_OPTS="${ZOPEN_CHECK_OPTSD}"
  fi
  if [ -z "${ZOPEN_INSTALL}" ]; then
    export ZOPEN_INSTALL="${ZOPEN_INSTALLD}"
  fi
  if [ -z "${ZOPEN_INSTALL_OPTS}" ]; then
    export ZOPEN_INSTALL_OPTS="-j${ZOPEN_NUM_JOBS} ${ZOPEN_INSTALL_OPTSD}"
  fi
  if [ -z "${ZOPEN_CLEAN}" ]; then
    export ZOPEN_CLEAN="${ZOPEN_CLEAND}"
  fi
  if [ -z "${ZOPEN_CLEAN_OPTS}" ]; then
    export ZOPEN_CLEAN_OPTS="${ZOPEN_CLEAN_OPTSD}"
  fi
  LOG_PFX=$(date +%C%y%m%d_%H%M%S)
}

#
# Tag files that we do not plan to put under 'git' for patching as binary
#
tagBinaryFiles()
{
  absdir="$1"
  (cd "${absdir}" && find . -name "*.pdf" -o -name "*.png" -o -name "*.jpg" -o -name "*.gif" -o -name "*.ttf" -o -name "*.wbmp" -o -name "*.gmo" -o -name "*.po" -o -name "*.der" -o -name "*.xz" -o -name "*.gz" ! -type d ! -type l | xargs -I {} chtag -b {})
}

#
# 'Quick' way to tag binary files. If the list of extensions grows, something more
# elegant is required
#
tagTree()
{
  dir="$1"
  absdir=$(cd ${dir} && echo "${PWD}")
  tagBinaryFiles "${absdir}"
}

checkGitVersion()
{
  if ! git --version > /dev/null 2> /dev/null; then
    printError "git is required to download from the git repo"
  fi
  gitraw=$(git --version | awk '{print $3;}')
  v=${gitraw%%.*}
  vr=${gitraw%.*}
  r=${vr##*.}
  if [ ${v} -lt 2 ] || [ ${r} -lt 39 ]; then
    printError "Need to be running at least git 2.39"
  fi
}

gitClone()
{
  gitname=$(basename "${ZOPEN_URL}")
  dir=${gitname%%.*}
  if [ -d "${dir}" ]; then
    printInfo "Using existing git clone'd directory ${dir}"
  else
    freshBuild=true
    printInfo "Clone and create ${dir}"
    if [ "${ZOPEN_CLONE_SUBMODULES}" = "yes" ]; then
      gitOptions=" --recurse-submodules"
    fi
    if ! runAndLog "git clone \"${ZOPEN_URL}\" ${gitOptions}"; then
      printError "Unable to clone ${gitname} from ${ZOPEN_URL}"
    fi
    if [ -n "${ZOPEN_GIT_BRANCH}" ]; then
      if ! git -C "${dir}" checkout "${ZOPEN_GIT_BRANCH}" > /dev/null; then
        printError"Unable to checkout ${ZOPEN_URL} branch ${ZOPEN_GIT_BRANCH}"
      fi
    elif [ -n "${ZOPEN_GIT_TAG}" ]; then
      if ! git -C "${dir}" checkout tags/"${ZOPEN_GIT_TAG}" -b "${ZOPEN_GIT_TAG}" > /dev/null; then
        printError"Unable to checkout ${ZOPEN_URL} tag ${ZOPEN_GIT_TAG}"
      fi
    fi
    tagTree "${dir}"
  fi
  echo "${dir}"
}

extractTarBall()
{
  tarballz="$1"
  dir="$2"
  noext=${tarballz%%.zip}
  if [ "x${noext}" = "x${tarballz}" ]; then
    # Standard tarball
    if ! tar --version > /dev/null 2> /dev/null; then
      printError "The tar open source package is required by zopen-build. The z/OS default 'tar' is insufficient"
    fi
    tarraw=$(tar --version | head -1 | awk '{print $4;}')
    v=${tarraw%%.*}
    r=${tarraw##*.}
    if [ ${v} -lt 1 ] || [ ${r} -lt 34 ]; then
      printError "Need to be running at least tar 1.34"
    fi

    printInfo "Extract tarball ${tarballz} into ${dir}"
    tar -axf "${tarballz}"
    if [ $? -gt 0 ]; then
      printError "Unable to untar ${tarballz}"
    fi
  else
    # Standard unzip
    # Remove the old directory contents if it already exists.
    # Keep the directory itself since there may be a symbolic
    # link pointing to it
    rm -rf "${noext}/*"
    printInfo "Extract zip ${tarballz} into ${dir}"
    out=$(unzip "${tarballz}" 2> /dev/null)
    if [ $? -gt 1 ]; then
      printError "unzip failed for ${tarballz}."
      echo "${out}" >&2
    fi
  fi
  rm -f "${tarballz}"
  tagTree "${dir}"
  cd "${dir}" || printError "Cannot cd to ${dir}"

  # Clean up .git* files since we will be creating our own local git repo for applying patches
  rm -rf .git* .travis*

  #
  # Need to keep this line and 'tagBinaryFiles' in sync
  # Perhaps this can be done with a function but be aware of blanks, newlines, etc. in file names
  #
  if [ "${ZOPEN_GIT_SETUP}x" = "Nx" ]; then
    if ! git init -b main . > /dev/null || ! git commit --allow-empty -m "Create Empty Repository for patch management" > /dev/null; then
      printError "Unable to initialize empty git repository for tarball"
    fi
  else
    if ! git init -b main . > /dev/null; then
      printError "Unable to initialize git repository for tarball"
    fi

    if ! asciiecho "
* text  working-tree-encoding=UTF-8
*.jpg binary
*.dvi binary
*.xz binary
*.gz binary
*.jpeg binary
*.png binary
*.gif binary
*.pdf binary
*.ttf binary
*.wbmp binary
*.gmo binary
*.po binary
*.der binary
" ".gitattributes"; then
      printError "Unable to create .gitattributes for tarball"
    fi

    if ! git add . > /dev/null; then
      printError "Unable to add files for git repository"
    fi

    if ! git commit --allow-empty -m "Create Repository for patch management" > /dev/null; then
      printError "Unable to commit git repository"
    fi
  fi
}

downloadTarBall()
{
  if ! curl --version > /dev/null; then
    printError "curl is required to download a tarball"
  fi
  tarballz=$(basename "${ZOPEN_URL}")
  dir=${tarballz%%.tar.*}
  dir=${dir%%.tgz}
  dir=${dir%%.zip}
  if [ -d "${dir}" ]; then
    echo "Using existing tarball directory ${dir}" >&2
  else
    freshBuild=true
    if ${verbose}; then
      printVerbose "curl ${ZOPEN_CURL_PARAMS} -L -o ${tarballz} ${ZOPEN_URL}"
    fi
    #
    # Some older tarballs (openssl) contain a pax_global_header file. Remove it
    # in advance so that unzip won't fail
    #
    rm -f pax_global_header

    #
    # Some sites fail on the first call because the name resolver hasn't resolved.
    # Make a first call to just get the headers and toss everything out just to
    # set up the cache (required for openssl)
    #
    curlCmd -I "${ZOPEN_URL}" > /dev/null 2>&1

    if ! curlCmd -L -o "${tarballz}" "${ZOPEN_URL}"; then
      if [ -f "${tarballz}" ] && [ $(wc -c "${tarballz}" | awk '{print $1}') -lt 1024 ]; then
        cat "${tarballz}" > /dev/null
      else
        printError "Re-try curl for diagnostics"
        curlCmd -L -o /dev/null "${ZOPEN_URL}"
      fi
      printError "Unable to download ${tarballz} from ${ZOPEN_URL}"
    fi
    # curl tags the file as ISO8859-1 (oops) so the tag has to be removed
    chtag -b "${tarballz}"

    extractTarBall "${tarballz}" "${dir}"
  fi
}

#
# This function applies patches previously created.
# To _create_ a patch, do the following:
#  -If required, create a sub-directory in the ${ZOPEN_ROOT}/patches directory called PR<x>, where <x> indicates
#   the order of the pull-request (e.g. if PR3 needs to be applied before your PR, make sure your PR
#   is at least PR4)
#  -Create, or update the PR readme called ${ZOPEN_ROOT}/patches/PR<x>/README.md describing this patch
#  -For each file you have changed:
#   -cd to the code directory and perform git diff <filename> >${ZOPEN_ROOT}/patches/PR<x>/<filename>.patch
#
applyPatches()
{
  if [ "${ZOPEN_TYPE}x" = "BAREx" ]; then
    return 0
  fi
  printHeader "Applying patches"
  if [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
    tarballz=$(basename "${ZOPEN_URL}")
    root_loc=${tarballz%%.tar.*}
    root_loc=${root_loc%%.tgz}
    code_dir="${ZOPEN_ROOT}/${root_loc}"
  else
    gitname=$(basename "${ZOPEN_URL}")
    code_dir="${ZOPEN_ROOT}/${gitname%%.*}"
  fi

  if [ ! -z "${ZOPEN_PATCH_DIR}" ]; then
    patch_try_dir="${ZOPEN_ROOT}/${ZOPEN_PATCH_DIR}"
    if [ -d "${patch_try_dir}" ]; then
      patch_dir="${patch_try_dir}"
    else
      printWarning "Specified patch directory ${patch_try_dir} does not exist - no patches to apply"
      return 0
    fi
  else
    if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
      buildtype_lower=$(echo "${ZOPEN_BUILD_LINE}" | tr '[A-Z]' '[a-z]')
      patch_try_dir="${ZOPEN_ROOT}/${buildtype_lower}-patches"
      if [ -d "${patch_try_dir}" ]; then
        patch_dir="${patch_try_dir}"
      fi
    fi

    if [ -z "${patch_dir}" ]; then
      patch_dir="${ZOPEN_ROOT}/patches"
      if ! [ -d "${patch_dir}" ]; then
        printWarning "${patch_dir} does not exist - no patches to apply"
        return 0
      fi
    fi
  fi

  printVerbose "Using patch directory ${patch_dir}"

  moved=false
  if [ -d "${code_dir}/.git-for-patches" ] && ! [ -d "${code_dir}/.git" ]; then
    mv "${code_dir}/.git-for-patches" "${code_dir}/.git" || exit 99
    moved=true
  fi

  if ! [ -d "${code_dir}/.git" ]; then
    printWarning "applyPatches requires ${code_dir} to be git-managed but there is no .git directory. No patches applied"
    return 0
  fi

  patches=$( (cd "${patch_dir}" && find . -name "*.patch" | sort))
  if [ -z "${patches}" ]; then
    printWarning "No patches in ${patch_dir} to apply"
    return 0
  fi
  results=$( (cd "${code_dir}" && git status --porcelain --untracked-files=no 2>&1))
  failedcount=0
  if [ "${results}" != '' ]; then
    printInfo "Existing Changes are active in ${code_dir}."
    printInfo "To re-apply patches, you need to reset the local git repo. "
    printInfo "  cd '${code_dir}' && git reset --hard"
    return 0
  else
    for patch in ${patches}; do
      p="${patch_dir}/${patch}"

      patchsize=$(wc -c "${p}" | awk '{ print $1 }')
      if [ ${patchsize} -eq 0 ]; then
        printWarning "Warning: patch file ${p} is empty - nothing to be done"
      else
        printInfo "Applying ${p}"
        if ${forcePatchApply}; then
          (cd "${code_dir}" && git apply --reject "${p}" 2>&1)
        else
          if ! out=$( (cd "${code_dir}" && git apply --check "${p}" 2>&1 && git apply "${p}" 2>&1)); then
            printSoftError "Patch of make tree failed (${p})."
            printSoftError "${out}"
            failedcount=$((failedcount + 1))
            break
          fi
        fi
      fi
    done
  fi

  # Tag the files that were just updated (again) as ASCII (hopefully can remove after we build our own git)
  (cd "${code_dir}" && git status --untracked-files -s | awk '{ $1=""; print; }' | xargs -I {} chtag -tcISO8859-1 {})
  if ${moved}; then
    mv "${code_dir}/.git" "${code_dir}/.git-for-patches" || exit 99
  fi

  if [ "${failedcount}" -ne 0 ]; then
    exit "${failedcount}"
  fi
  return 0
}

getCode()
{
  printHeader "Building ${ZOPEN_ROOT}"
  cd "${ZOPEN_ROOT}" || exit 99

  if [ "${ZOPEN_TYPE}x" = "BAREx" ]; then
    return 0
  fi

  checkGitVersion

  if [ "${ZOPEN_TYPE}x" = "GITx" ]; then
    printInfo "Checking if git directory already cloned"
    if ! gitClone; then
      return 4
    fi
  elif [ "${ZOPEN_TYPE}x" = "TARBALLx" ]; then
    printInfo "Checking if tarball already downloaded"
    if ! downloadTarBall; then
      return 4
    fi
  else
    printError "ZOPEN_TYPE should be one of GIT or TARBALL"
    return 4
  fi
}

create_fifo_pipe()
{
  file="$1"
  if [ -p ${TMP_FIFO_PIPE} ]; then
    rm ${TMP_FIFO_PIPE}
  fi
  mkfifo ${TMP_FIFO_PIPE}
  chtag -tc 819 ${TMP_FIFO_PIPE}
  touch ${file} && chtag -tc 819 ${file}
  tee ${file} < ${TMP_FIFO_PIPE} &
  TEE_PID=$!
}

cleanup()
{
  if [ -n "${ZOPEN_CLEAN_CMD}" ] && [ -f "${ZOPEN_LOG_DIR}/config.success" ] && ! ${freshBuild}; then
    printHeader "Running Cleanup"
    cleanlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_clean.log"
    create_fifo_pipe "${cleanlog}"
    if ! runAndLog "${ZOPEN_CLEAN_CMD} >${TMP_FIFO_PIPE} 2>&1"; then
      printError "Cleanup failed. Log: ${cleanlog}" >&2
    fi
  fi
  rm -f ${ZOPEN_LOG_DIR}/bootstrap.success
  rm -f ${ZOPEN_LOG_DIR}/config.success
}

bootstrap()
{
  bootstrapStartTime=${SECONDS}
  if [ -n "${ZOPEN_BOOTSTRAP_CMD}" ]; then
    printHeader "Running Bootstrap"
    if [ -r "${ZOPEN_LOG_DIR}/bootstrap.success" ]; then
      echo "Using previous successful bootstrap. Specify -f to force a bootstrap." >&2
    else
      bootlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_bootstrap.log"
      create_fifo_pipe "${bootlog}"
      if ! runAndLog "${ZOPEN_BOOTSTRAP_CMD} >${TMP_FIFO_PIPE} 2>&1"; then
        printError "Bootstrap failed. Log: ${bootlog}" >&2
      fi
      touch ${ZOPEN_LOG_DIR}/bootstrap.success
    fi
  else
    printHeader "Skip Bootstrap"
  fi
  printElapsedTime verbose "bootstrap" "${bootstrapStartTime}"

}

configure()
{
  if command -V "${ZOPEN_PRE_CONFIGURE_CODE}" >/dev/null 2>&1; then
    printVerbose "Running ${ZOPEN_PRE_CONFIGURE_CODE}"
    if ! "${ZOPEN_PRE_CONFIGURE_CODE}"; then
        printError "Pre configure failed."
    fi
  fi

  configureStartTime=${SECONDS}
  if [ -n "${ZOPEN_CONFIGURE_CMD}" ]; then
    printHeader "Running Configure"
    if [ -r "${ZOPEN_LOG_DIR}/config.success" ]; then
      echo "Using previous successful configuration. Specify -f to force a configure." >&2
    else
      configlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_config.log"
      create_fifo_pipe "${configlog}"
      if ! runAndLog "${ZOPEN_CONFIGURE_CMD} >${TMP_FIFO_PIPE} 2>&1"; then
        if [ "${ZOPEN_CONFIGURE_MINIMAL}" = "yes" ]; then
          printError "Configure (minimal) failed. Log: ${configlog}"
        else
          printError "Configure (full) failed. Log: ${configlog}"
        fi
      fi
      touch ${ZOPEN_LOG_DIR}/config.success
    fi
  else
    printHeader "Skip Configure"
  fi
  printElapsedTime verbose "configure" "${configureStartTime}"
}

build()
{
  buildStartTime=${SECONDS}
  if command -V "${ZOPEN_PRE_BUILD_CODE}" > /dev/null 2>&1; then
    printVerbose "Running ${ZOPEN_PRE_BUILD_CODE}"
    if ! "${ZOPEN_PRE_BUILD_CODE}"; then
      printError "Pre build failed."
    fi
  fi

  makelog="${ZOPEN_LOG_DIR}/${LOG_PFX}_build.log"
  if [ -n "${ZOPEN_MAKE_CMD}" ]; then
    printHeader "Running Build"
    create_fifo_pipe "${makelog}"
    if ! runAndLog "${ZOPEN_MAKE_CMD} > ${TMP_FIFO_PIPE} 2>&1"; then
      if [ "${ZOPEN_MAKE_MINIMAL}" = "yes" ]; then
        printError "Make (minimal) failed. Log: ${makelog}"
      else
        printError "Make (full) failed. Log: ${makelog}"
      fi
    fi
  else
    printHeader "Skipping Build"
  fi
  printElapsedTime verbose "build" "${buildStartTime}"
}

check()
{
  checkStartTime=${SECONDS}
  if command -V "${ZOPEN_PRE_CHECK_CODE}" > /dev/null 2>&1; then
    printVerbose "Running ${ZOPEN_PRE_CHECK_CODE}"
    "${ZOPEN_PRE_CHECK_CODE}" "${ZOPEN_INSTALL_DIR}"
  fi
  checklog="${ZOPEN_LOG_DIR}/${LOG_PFX}_check.log"
  results=${ZOPEN_TEST_STATUS_SKIPPED} # skipped
  if [ -n "${ZOPEN_CHECK_CMD}" ]; then
    printHeader "Running Check"
    create_fifo_pipe "${checklog}"
    runInBackgroundWithTimeoutAndLog "${ZOPEN_CHECK_CMD} > ${TMP_FIFO_PIPE} 2>&1" "${ZOPEN_CHECK_TIMEOUT}"
    if command -V "${ZOPEN_CHECK_RESULTS_CODE}" > /dev/null 2>&1; then
      testStatus="$(${ZOPEN_CHECK_RESULTS_CODE} "${ZOPEN_LOG_DIR}" "${LOG_PFX}")"
      printVerbose "Test status:\n${testStatus}"
      testStatusError=false
      checkTotalTests=false
      if echo "${testStatus}" | grep -q -E "actualFailures:[ ]*[0-9]+"; then
        failures=$(echo "${testStatus}" | grep "actualFailures:" | sed -e "s/.*actualFailures://" | tr -d ' ')
      else
        printSoftError "${ZOPEN_CHECK_RESULTS_CODE} needs to emit an actualFailures:<number> line"
        testStatusError=true
      fi
      if echo "${testStatus}" | grep -q -E "expectedFailures:[ ]*[0-9]+"; then
        expectedFailures=$(echo "${testStatus}" | grep "expectedFailures:" | sed -e "s/.*expectedFailures://" | tr -d ' ')
      else
        printSoftError "${ZOPEN_CHECK_RESULTS_CODE} needs to emit an expectedFailures:<number> line"
        testStatusError=true
      fi
      if echo "${testStatus}" | grep -q -E "totalTests:[ ]*[0-9]+"; then
        totalTests=$(echo "${testStatus}" | grep "totalTests:" | sed -e "s/.*totalTests://" | tr -d ' ')
        if [ ${totalTests} -eq 0 ]; then
          printSoftError "Total tests is 0"
          testStatusError=true
        fi
      else
        printSoftError "${ZOPEN_CHECK_RESULTS_CODE} needs to emit an totalTests:<number> line"
        testStatusError=true
      fi
      if echo "${testStatus}" | grep -q -E "expectedTotalTests:[ ]*[0-9]+"; then
        expectedTotalTests=$(echo "${testStatus}" | grep "expectedTotalTests:" | sed -e "s/.*expectedTotalTests://" | tr -d ' ')
        checkTotalTests=true
      fi
      if ${testStatusError}; then
        printError "Test Status:\n${testStatus}"
      fi
      success="$((totalTests - failures))"
      percent="$(echo "${success}" "${totalTests}" | awk '{printf "%.0f", $1 * 100 / $2}')"
      percenthundreth="$(echo "${success}" "${totalTests}" | awk '{printf "%.2f", $1 * 100 / $2}')"
      summary="${success} tests pass out of ${totalTests} tests - ${percenthundreth}% success rate"
      printVerbose "Test results: ${summary}"
      if ! [ ${percent} -eq ${percent} ]; then # not a number
        results=${ZOPEN_TEST_STATUS_ERROR}
        ZOPEN_STATUS="Error (could not run tests)" # bad return code from check results
      else
        if [ ${percent} -eq 100 ]; then
          results=${ZOPEN_TEST_STATUS_ALL_PASSED}
          ZOPEN_STATUS="Green (${summary})" # All tests passed
        elif [ ${percent} -ge 50 ]; then
          results=${ZOPEN_TEST_STATUS_MOST_PASSED}
          ZOPEN_STATUS="Blue (${summary})" # Most tests passed
        elif [ ${percent} -eq 0 ]; then
          results=${ZOPEN_TEST_STATUS_NONE_PASSED}
          ZOPEN_STATUS="Red (${summary})" # Pretty much non-functional
        elif [ ${percent} -lt 50 ]; then
          results=${ZOPEN_TEST_STATUS_SOME_PASSED}
          ZOPEN_STATUS="Yellow (${summary})" # Most tests failed
        fi
      fi
      if ${checkTotalTests}; then
        if [ ${totalTests} -lt ${expectedTotalTests} ]; then
          printElapsedTime verbose "check" "${checkStartTime}"
          printError "Executed tests (${totalTests}) is less than expected (${expectedTotalTests}). Failing..."
        fi
      fi
      if [ ${failures} -le ${expectedFailures} ]; then
        printElapsedTime verbose "check" "${checkStartTime}"
        return 0
      else
        printElapsedTime verbose "check" "${checkStartTime}"
        printError "Failures (${failures}) not less than than expected (${expectedFailures}). Failing..."
      fi
    fi
  else
    printHeader "Skipping Check"
    ZOPEN_STATUS="Skipped (tests skipped)" # Skipped tests
  fi
  printElapsedTime verbose "check" "${checkStartTime}"
}

replaceHardcodedPath()
{
  orig=$1
  replaced=$2
  f=$3
  hasHardcodedPaths=true
  printVerbose "Replacing ${orig} in ${f}"
  # only substitute text
  if /bin/sed -e "" ${f} 2> /dev/null 1>&2; then
    isWritable=true
    if [ ! -w "${f}" ]; then
      isWriteable=false
      chmod "+w" ${f}
    fi
    cp ${f} ${f}.old &&
      # replace hardcoded path and strip out the -suffix in name to match active
      sed -e "s#${orig}/\([^/]\+\)/[^/\n '\";]*#${replaced}/\1/\1#g" ${f}.old > ${f} &&
      rm ${f}.old
    if ! ${isWriteable}; then
      chmod "-w" ${f}
    fi
  fi
}

replaceHardcodedPaths()
{
  ZOPEN_INSTALL_PREFIX="${ZOPEN_INSTALL_DIR}/../../"
  ZOPEN_INSTALL_PREFIX=$(cd "${ZOPEN_INSTALL_PREFIX}" > /dev/null 2>&1 && pwd -P)

  printHeader "Replacing hardcoded ${ZOPEN_INSTALL_PREFIX} path"
  hasHardcodedPaths=false
  for f in $(find ${ZOPEN_INSTALL_DIR}/ -type f | xargs grep -l "${ZOPEN_INSTALL_PREFIX}" 2> /dev/null); do
    hasHardcodedPaths=true
    replaceHardcodedPath "${ZOPEN_INSTALL_PREFIX}" "ZOPEN_INSTALL_PREFIX" "${f}"
  done
}

createEnvAndSetup()
{
  printHeader "Creating ${ZOPEN_INSTALL_DIR}/.env"
  projectName=$(echo ${ZOPEN_NAME} | cut -d "-" -f 1 | awk '{print toupper($0)}')
  cat << zz > "${ZOPEN_INSTALL_DIR}/.env"
if ! [ -f ./.env ]; then
  echo "Need to source from the .env directory" >&2
  return 1
fi

dropTagRedirEnvar=false
if [ "\${_BPX_TERMPATH-x}" = "OMVS" ] && [ -z "\$_TAG_REDIR_OUT" ]; then
  dropTagRedirEnvar=true;
fi

export _TAG_REDIR_IN=txt
export _TAG_REDIR_ERR=txt
export _TAG_REDIR_OUT=txt

deleteDuplicateEntries()
{
  value=\$1
  delim=\$2
  echo "\$value\$delim" | awk -v RS="\$delim" '!(\$0 in a) {a[\$0]; printf("%s%s", col, \$0); col=RS; }' | sed "s/\${delim}$//"
}

_CEE_RUNOPTS="\$_CEE_RUNOPTS FILETAG(AUTOCVT,AUTOTAG) POSIX(ON)"
# Remove spaces in between brackets
_CEE_RUNOPTS="\$(echo "\$_CEE_RUNOPTS" | awk '{gsub(/\([ \t]*/, "("); gsub(/[ \t]*\)/, ")"); gsub(/[ \t]*,[ \t]*/, ","); print}')"
export _CEE_RUNOPTS="\$(deleteDuplicateEntries "\$_CEE_RUNOPTS" " ")"

if [ -z "${_BPXK_AUTOCVT}" ] || [ "${_BPXK_AUTOCVT}" = "OFF" ]; then
  export _BPXK_AUTOCVT=ON
fi

export ${projectName}_HOME="\${PWD}"
zz

  if [ -d "${ZOPEN_INSTALL_DIR}/bin" ]; then
    echo "PATH=\"\${${projectName}_HOME}/bin:\${${projectName}_HOME}/altbin:\$PATH\"" >> "${ZOPEN_INSTALL_DIR}/.env"
    echo "export PATH=\"\$(deleteDuplicateEntries \"\$PATH\" \":\")\"" >> "${ZOPEN_INSTALL_DIR}/.env"
  fi
  if [ -d "${ZOPEN_INSTALL_DIR}/lib" ]; then
    echo "LIBPATH=\"\${${projectName}_HOME}/lib:\$LIBPATH\"" >> "${ZOPEN_INSTALL_DIR}/.env"
    echo "export LIBPATH=\"\$(deleteDuplicateEntries \"\$LIBPATH\" \":\")\"" >> "${ZOPEN_INSTALL_DIR}/.env"
  fi
  if [ -d "${ZOPEN_INSTALL_DIR}/share/man" ] || [ "${projectName}" = "GIT" ]; then
    echo "MANPATH=\"\${${projectName}_HOME}/share/man:\$MANPATH\"" >> "${ZOPEN_INSTALL_DIR}/.env"
    echo "export MANPATH=\"\$(deleteDuplicateEntries \"\$MANPATH\" \":\")\"" >> "${ZOPEN_INSTALL_DIR}/.env"
  fi
  if command -V "${ZOPEN_APPEND_TO_ENV_CODE}" > /dev/null 2>&1; then
    printVerbose "Appending additional environment variables..."
    append_to_env="$(${ZOPEN_APPEND_TO_ENV_CODE})"
  else
    append_to_env="# nothing to do"
  fi

  echo "${append_to_env}" > "${ZOPEN_INSTALL_DIR}/.appenv"
  echo ". ./.appenv" >> "${ZOPEN_INSTALL_DIR}/.env"

  cat << zz >> "${ZOPEN_INSTALL_DIR}/.env"
if \$dropTagRedirEnvar; then
  unset _TAG_REDIR_OUT
fi
zz

  # Create setup.sh script
  projectName_lower=$(echo "${projectName}" | tr '[A-Z]' '[a-z]')
  cat << zz > "${ZOPEN_INSTALL_DIR}/setup.sh"
#!/bin/sh
touch \".installing\"
SETUPDIR="\$(cd "\$(dirname "\$0")" > /dev/null 2>&1 && pwd -P)"
. ./.env
echo \"Setting up ${projectName_lower}...\"
zz

  if ${hasHardcodedPaths}; then
    cat << zz >> "${ZOPEN_INSTALL_DIR}/setup.sh"
if [ -f .replacedpath ]; then
  REPLACE_PREFIX_PATH="\$(cat .replacedpath | head -1)"
else
  REPLACE_PREFIX_PATH="ZOPEN_INSTALL_PREFIX"
fi

replaceHardcodedPath() {
  orig=\$1
  replaced=\$2
  root=\$3
  f=\$4
  # only substitute text files
  if /bin/sed -e "" \${f} 2> /dev/null 1>&2; then
    if [ \"\$f\" != \"\${root}/setup.sh\" ] && [ \"\$f\" != \"\${root}/.env\" ] && [ \"\$f\" != \"\${root}/.replacedpath\" ]; then
      isWritable=true
      if [ ! -w "\$f" ]; then
        isWriteable=false
        chmod "+w" \$f
      fi
      cp \$f \$f.tmp && \\
      /bin/sed -e \"s#\${orig}#\${replaced}#g\" \$f.tmp > \$f && \\
      rm -f \$f.tmp;
      if ! \$isWriteable; then
        chmod "-w" \$f
      fi
    fi
  fi
}
if [ ! -d "\$${projectName}_HOME" ]; then
  echo "WARNING: ${projectName}_HOME (set to \"\$${projectName}_HOME\") was not set properly."
  ${projectName}_HOME="\${SETUPDIR}"
fi

if [ ! -d "\$${projectName}_HOME" ]; then
  echo "ERROR: ${projectName}_HOME (set to \"\$${projectName}_HOME\") is not a directory. Exiting."
  exit 2
fi

echo "Replacing hardcoded paths in \$${projectName}_HOME..."
ZOPEN_INSTALL_PREFIX="\$${projectName}_HOME/../../"
ZOPEN_INSTALL_PREFIX=\$(cd "\${ZOPEN_INSTALL_PREFIX}" >/dev/null 2>&1 && pwd -P)
for f in \$(/bin/find \$${projectName}_HOME/ -type f | /bin/xargs grep -l \"\$REPLACE_PREFIX_PATH\" 2>/dev/null); do
  replaceHardcodedPath "\$REPLACE_PREFIX_PATH" "\${ZOPEN_INSTALL_PREFIX}" "\$${projectName}_HOME" \$f
done
echo "\${ZOPEN_INSTALL_PREFIX}" > .replacedpath
zz
  fi

  if command -V "${ZOPEN_APPEND_TO_SETUP_CODE}" > /dev/null 2>&1; then
    printVerbose "Appending additional setup code..."
    append_to_setup="$(${ZOPEN_APPEND_TO_SETUP_CODE})"
    echo "${append_to_setup}" >> "${ZOPEN_INSTALL_DIR}/setup.sh"
  fi

  cat << zz >> "${ZOPEN_INSTALL_DIR}/setup.sh"
echo \"Setup completed.\"
touch \".installed\"
rm \".installing\"
zz

  echo "#!/bin/sh" > "${ZOPEN_INSTALL_DIR}/install_test.sh"
  chmod +x "${ZOPEN_INSTALL_DIR}/install_test.sh"
  if command -V "${ZOPEN_APPEND_TO_VALIDATE_CODE}" > /dev/null 2>&1; then
    printVerbose "Appending additional validate code..."
    append_to_validate="$(${ZOPEN_APPEND_TO_VALIDATE_CODE})"
    echo "${append_to_validate}" >> "${ZOPEN_INSTALL_DIR}/install_test.sh"
  fi
  cat << zz >> "${ZOPEN_INSTALL_DIR}/install_test.sh"
exit 0;
zz

  if [ ! -z "${ZOPEN_RUNTIME_DEPS}" ]; then
    cat << ZZ >> "${ZOPEN_INSTALL_DIR}/.env"
if [ -f ".depsenv" ] && [ -z "\$ZOPEN_SOURCING_DEPS" ] ; then
  ZOPEN_SOURCING_DEPS=1
  . ./.depsenv
fi
if [ ! -z "\$ZOPEN_SOURCING_DEPS" ]; then
  unset ZOPEN_SOURCING_DEPS
fi
ZZ
    printHeader "Install dependencies: ${ZOPEN_RUNTIME_DEPS}"
    varName=$(echo "${projectName}" | sed -e "s/-/_/g")
    cat << ZZ >> "${ZOPEN_INSTALL_DIR}/.depsenv"
${varName}_originalDir="\$OLDPWD"
ZZ
    echo "${ZOPEN_RUNTIME_DEPS}" | xargs | tr ' ' '\n' | sort | while read dep; do
      # Use the first path specified in the dependency search list to install to
      if $noInstallRuntimeDeps; then
        if ! runAndLog "PATH=\"${ZOPEN_OLD_PATH}\" ${MYDIR}/zopen-install --install-or-upgrade ${dep} -v --no-deps -y"; then
          printError "Failed to install dependencies"
        fi
      fi

      printVerbose "Generating .depsenv"
      parent=""
      depth=$depsDepth
      while [ $depth -gt 0 ]; do
        parent="../${parent}"
        depth=$((depth - 1))
      done
      depth=$depsDepth
      while [ $depth -gt 0 ]; do
        parent="$parent/${dep}"
        depth=$((depth - 1))
      done
      cat << ZZ >> "${ZOPEN_INSTALL_DIR}/.depsenv"
if [ -f "${parent}/.env" ]; then
  if [[ \$(type echo) == 'echo is a shell builtin' ]]; then
    pushd "${parent}" >/dev/null
    . ./.env
    popd >/dev/null
  else
    cd "${parent}" && . ./.env; cd - >/dev/null
  fi
fi
ZZ
    done
    cat << ZZ >> "${ZOPEN_INSTALL_DIR}/.depsenv"
OLDPWD="\$${varName}_originalDir"
ZZ
  a2e ${ZOPEN_INSTALL_DIR}/.depsenv
  fi

  # Add call to setup.sh
  cat << zz >> "${ZOPEN_INSTALL_DIR}/.env"
# Run setup.sh if it hasn't been run yet
if [ ! -f \".installed\" ] && [ ! -f \".installing\" ] && [ -x \"setup.sh\" ]; then
  ./setup.sh
fi
zz

  # Zopen "entry point" files should be in IBM-1047
  a2e ${ZOPEN_INSTALL_DIR}/setup.sh
  a2e ${ZOPEN_INSTALL_DIR}/.appenv
  a2e ${ZOPEN_INSTALL_DIR}/.env

  chmod 755 "${ZOPEN_INSTALL_DIR}/setup.sh"
}

createReadme()
{
  printHeader "Creating ${ZOPEN_INSTALL_DIR}/README.md"
  cp "${MYDIR}/../data/README_header.md" "${ZOPEN_INSTALL_DIR}/README.md"
  if [ -f "${ZOPEN_ROOT}/README.md" ]; then
    cat "${ZOPEN_ROOT}/README.md" >> "${ZOPEN_INSTALL_DIR}/README.md"
  fi
  cat "${MYDIR}/../data/README_footer.md" >> "${ZOPEN_INSTALL_DIR}/README.md"
}

getPathSizeInBytes()
{
  du -ks "$1" | awk '{print $1 * 1024}'
}

generateMetadataJSON()
{
  printHeader "Creating Metadata JSON"
  package=${ZOPEN_NAME}
  name=$(echo $package | cut -d "-" -f 1)
  if [ -z "${versionString}" ]; then
    version=$(echo ${package} | cut -d "-" -f 2)

  else
    version="${versionString}"
  fi

  # Make the version OCI compat
  case "${version}" in
  *.*.*.*) ;;
  *.*.*) version="${version}.0" ;;
  *.*) version="${version}.0.0" ;;
  *) version="1.0.0.0" ;;
  esac

  total_size=$(getPathSizeInBytes "${ZOPEN_INSTALL_DIR}")

  if [ -z "$totalTests" ]; then
    total_tests=-1
  fi
  if [ -z "$success" ]; then
    success=-1
  fi

  if [ -n "$(command -v zopen_install_caveats)" ]; then
    caveats="$(zopen_install_caveats)"
  fi
    
  metadata_version_scheme="0.2" # Update if we add breaking changes to the json format
  cat <<zz > "${ZOPEN_INSTALL_DIR}/metadata.json"
{
"version_scheme": "${metadata_version_scheme}",
"product": {
  "name": "${name}",
  "version": "${version}",
  "release": "${LOG_PFX}",
  "summary": "${name} on z/OS",
  "repo": "${ZOPEN_REMOTE_URL}",
  "license": "${ZOPEN_REMOTE_URL}/blob/main/patches/LICENSE",
  "zopen_license": "${ZOPEN_REMOTE_URL}/blob/main/LICENSE",
  "categories": "${ZOPEN_CATEGORIES}",
  "buildline": "${ZOPEN_BUILD_LINE}",
  "source_type": "${ZOPEN_TYPE}",
  "test_status": {
    "total_tests": "${totalTests}",
    "total_success": "${success}"
  },
  "size": "${total_size}",
  "commitsha": "${ZOPEN_COMMIT_SHA}",
  "community_commitsha": "${ZOPEN_PROJECT_HEAD_COMMIT_SHA}",
zz

#TODO: Clean this code up
# Build Dependencies
cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
  "build_dependencies": [
zz

#TODO: add versionRanges, for now set to null
isFirst=true
echo "${ZOPEN_DEPS}" | xargs | tr ' ' '\n' | sort | while read dep; do
if ! $isFirst; then
  echo "," >> "${ZOPEN_INSTALL_DIR}/metadata.json"
fi
cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
      {
        "name": "${dep}",
        "versionRange": null
      }
zz
isFirst=false
done

# Runtime Dependencies
cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
  ],"runtime_dependencies": [
zz

#TODO: add versionRanges, for now set to null
isFirst=true
echo "${ZOPEN_RUNTIME_DEPS}" | xargs | tr ' ' '\n' | sort | while read dep; do
if ! $isFirst; then
  echo "," >> "${ZOPEN_INSTALL_DIR}/metadata.json"
fi
cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
      {
        "name": "${dep}",
        "versionRange": null
      }
zz
isFirst=false
done

# System Prerequisites
cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
  ],"system_prereqs": [
zz

isFirst=true
echo "${ZOPEN_SYSTEM_PREREQ}" | xargs | tr ' ' '\n' | sort | while read prereq; do
if ! $isFirst; then
  echo "," >> "${ZOPEN_INSTALL_DIR}/metadata.json"
fi
cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
      {
        "name": "${prereq}"
      }
zz
isFirst=false
done

cat <<zz >> "${ZOPEN_INSTALL_DIR}/metadata.json"
  ]
}}
zz

  if ! jq -e '.' "${ZOPEN_INSTALL_DIR}/metadata.json" 1>/dev/null 2>&1; then
    printError "${ZOPEN_INSTALL_DIR}/metadata.json contains invalid json: $(cat ${ZOPEN_INSTALL_DIR}/metadata.json)"
  fi
  if [ -n "${caveats}" ]; then
    jq --arg caveats "${caveats}" \
        '.product += { "install_caveats": $caveats }' "${ZOPEN_INSTALL_DIR}/metadata.json" > "${ZOPEN_INSTALL_DIR}/metadata.json.tmp"
    mv "${ZOPEN_INSTALL_DIR}/metadata.json.tmp" "${ZOPEN_INSTALL_DIR}/metadata.json"
  fi
  # Format json
  jq "." "${ZOPEN_INSTALL_DIR}/metadata.json" > "${ZOPEN_ROOT}/install/metadata.json"
  cp "${ZOPEN_ROOT}/install/metadata.json" "${ZOPEN_INSTALL_DIR}/metadata.json"
}

install()
{
  installStartTime=${SECONDS}
  if [ -n "${ZOPEN_INSTALL_CMD}" ]; then
    if [ -d "${ZOPEN_INSTALL_DIR}" ]; then
      printVerbose "${ZOPEN_INSTALL_DIR} already exists, deleting..."
      rm -rf "${ZOPEN_INSTALL_DIR}"
    fi
    if command -V "${ZOPEN_PRE_INSTALL_CODE}" > /dev/null 2>&1; then
      printVerbose "Running ${ZOPEN_PRE_INSTALL_CODE}"
      "${ZOPEN_PRE_INSTALL_CODE}" "${ZOPEN_INSTALL_DIR}"
    fi

    printHeader "Running Install"
    installlog="${ZOPEN_LOG_DIR}/${LOG_PFX}_install.log"
    create_fifo_pipe "${installlog}"
    if ! runAndLog "${ZOPEN_INSTALL_CMD} > ${TMP_FIFO_PIPE} 2>&1"; then
      printError "Install failed. Log: ${installlog}"
    fi
    replaceHardcodedPaths
    createEnvAndSetup

    if command -V "${ZOPEN_POST_INSTALL_CODE}" > /dev/null 2>&1; then
      printVerbose "Running ${ZOPEN_POST_INSTALL_CODE}"
      if ! "${ZOPEN_POST_INSTALL_CODE}" "${ZOPEN_INSTALL_DIR}"; then
        printError "Post install failed.${installlog}"
      fi
    fi

    createReadme

    # Store test.status into installed dir and build dir for cicd
    asciiecho "${ZOPEN_STATUS}" "${ZOPEN_ROOT}/install/test.status"
    cp "${ZOPEN_ROOT}/install/test.status" "${ZOPEN_INSTALL_DIR}/test.status"

    if [ -z "${ZOPEN_BUILD_LINE}" ]; then
      ZOPEN_BUILD_LINE="STABLE"
    fi
    asciiecho "${ZOPEN_BUILD_LINE}" "${ZOPEN_INSTALL_DIR}/.buildline"

    if [ -z "$(command -v zopen_get_version)" ]; then
      printError "A zopen_get_version() function must be defined in the buildenv to extract the version contents"
    else
      versionString=$(zopen_get_version)
      echo ${versionString} | awk -F. '{
        if (NF < 1 || NF > 4) {
          exit 1
        }
        if ($1 ~ /[^0-9]/) {
          exit 1
        }
        if ($2 ~ /[^0-9]/) {
          exit 1
        }
        if (NF >= 3 && $3 ~ /[^0-9A-Za-z-]+/) {
          exit 1
        }
        if (NF == 4 && $4 !~ /[0-9A-Za-z-]+/) {
          exit 1
        }
        exit 0
      }'

      if [ $? -ne 0 ]; then
        printError "The version string \"${versionString}\" uses an invalid version format"
      fi
      asciiecho "${versionString}" "${ZOPEN_INSTALL_DIR}/.version"
      cp "${ZOPEN_INSTALL_DIR}/.version" "${ZOPEN_ROOT}/install/"
    fi

    asciiecho "$(echo "${ZOPEN_RUNTIME_DEPS}" | xargs | tr ' ' '\n' | sort -u | xargs)" "${ZOPEN_INSTALL_DIR}/.runtimedeps"
    cp "${ZOPEN_INSTALL_DIR}/.runtimedeps" "${ZOPEN_ROOT}/install/"

    buildDeps="${ZOPEN_DEPS}"
    asciiecho "$(echo "${buildDeps}" | xargs | tr ' ' '\n' | sort -u | xargs)" "${ZOPEN_INSTALL_DIR}/.builddeps"
    cp "${ZOPEN_INSTALL_DIR}/.builddeps" "${ZOPEN_ROOT}/install/"

    asciiecho "${LOG_PFX}" "${ZOPEN_INSTALL_DIR}/.buildtimestamp"

    generateMetadataJSON

    if ${generatePax}; then
      printHeader "Generating pax.Z from ${ZOPEN_INSTALL_DIR}"
      if ! runAndLog "${ZOPEN_PAX_CMD}"; then
        printError "Could not generate pax \"${paxFileName}\""
      fi

      #TODO: Hack so that we can use coreutils md5sum without impacting builds
      ZOPEN_DEPS="${ZOPEN_DEPS} coreutils jq"
      if [ "${signPax}" = "true" ] && ( [ -z "${ZOPEN_GPG_SECRET_KEY_FILE}" ] || [ -z "${ZOPEN_GPG_SECRET_KEY_PASSPHRASE_FILE}" ] || [ -z "${ZOPEN_GPG_PUBLIC_KEY_FILE}" ] || [ ! -r "${ZOPEN_GPG_SECRET_KEY_FILE}" ] || [ ! -r "${ZOPEN_GPG_SECRET_KEY_PASSPHRASE_FILE}" ] || [ ! -r "${ZOPEN_GPG_PUBLIC_KEY_FILE}" ] ); then
		printError "GPG keyring environment variables are not set! You can omit the --sign-pax option to bypass this"
       else
		ZOPEN_DEPS="${ZOPEN_DEPS} gpg"
       fi

       setDepsEnv

      pax_size=$(getPathSizeInBytes "${paxFileName}")
      md5sum=$(md5sum "${paxFileName}" | awk '{print $1}')

      #If signPax is true, rest of variables check is done before setDepsEnv
      if [ "${signPax}" = "true" ]; then
                signPaxFile
                public_key=$(jq -Rs . < ${ZOPEN_GPG_PUBLIC_KEY_FILE})
      fi

      if [[ -n "${SIGNATURE}" ]]; then
         cat ${ZOPEN_INSTALL_DIR}/metadata.json
         jq --arg pax "${ZOPEN_NAME}.${LOG_PFX}.zos.pax.Z" \
            --arg pax_size "$pax_size" \
            --arg md5 "$md5sum" \
            --arg signature "$SIGNATURE" \
            --arg public_key "$public_key" \
            '.product |= . + { "pax": $pax, "pax_size": $pax_size, "md5": $md5, "signature": $signature, "public_key": $public_key }' \
            "${ZOPEN_ROOT}/install/metadata.json" > "${ZOPEN_ROOT}/install/metadata.json.tmp"
      else
        jq '.product |= . + { "pax": "'${ZOPEN_NAME}.${LOG_PFX}.zos.pax.Z'", "pax_size": "'${pax_size}'", "md5": "'${md5sum}'" }' "${ZOPEN_ROOT}/install/metadata.json" > "${ZOPEN_ROOT}/install/metadata.json.tmp"
      fi
      mv "${ZOPEN_ROOT}/install/metadata.json.tmp" "${ZOPEN_ROOT}/install/metadata.json"
    fi

    if ${setActive}; then
      PROJECT_NAME="$(echo ${ZOPEN_NAME} | cut -d'-' -f1)"
      mergeIntoSystem "${PROJECT_NAME}" "${ZOPEN_INSTALL_DIR}" "${ZOPEN_ROOTFS}"
      mkdir -p "${ZOPEN_ROOTFS}/etc/profiled/${name}"
      cat << EOF > "${ZOPEN_ROOTFS}/etc/profiled/${name}/dotenv"
curdir=\$(pwd)
cd "${ZOPEN_INSTALL_DIR}" >/dev/null 2>&1
if [ -f ".appenv" ]; then
  . ./.appenv
fi
cd \$curdir  >/dev/null 2>&1
EOF
      printInfo "- Sourcing environment to run any setup"
      cd "${ZOPEN_INSTALL_DIR}" && ./setup.sh
      printVerbose "Marking this version as installed"
      touch "${ZOPEN_INSTALL_DIR}/.active"
    fi
    generateOCI ${ZOPEN_NAME}
  else
    printHeader "Skipping Install"
  fi
  printElapsedTime verbose "install" "${installStartTime}"
}

#
# Figure out the 'bootstrap', 'configure', 'make', 'check', and 'install' commands here so that
# they are available within an interactive shell environment using --shell.
#
resolveCommands()
{
  if [ -z "${ZOPEN_NAME}" ]; then
    ZOPEN_NAME="${dir}"
    if [ "${ZOPEN_TYPE}x" = "GITx" ]; then
      branch=$(git rev-parse --abbrev-ref HEAD 2>&1 | sed "s/\//./g")
      ZOPEN_NAME="${dir}-${branch}"
    fi
  fi
  ZOPEN_PROJECT_HEAD_COMMIT_SHA="$(git rev-parse HEAD)"

  # Check if ZOPEN_NAME contains a "-"
  if [ -z "$(echo "${ZOPEN_NAME}" | grep '-')" ]; then
    # If not, add the '-DEV' suffix so as not to collide with zopen installed packages
    ZOPEN_NAME="${ZOPEN_NAME}-DEV"
  fi
  if [ -z "${ZOPEN_INSTALL_DIR}" ]; then
    PROJECT_NAME="$(echo ${ZOPEN_NAME} | cut -d'-' -f1)"
    export ZOPEN_INSTALL_DIR="${ZOPEN_PKGINSTALL}/${PROJECT_NAME}/${ZOPEN_NAME}" # Install into dev location
  fi
  if [ -z "${ZOPEN_LOG_DIR}" ]; then
    export ZOPEN_LOG_DIR="${ZOPEN_ROOT}/log"
    if [ ! -z "${ZOPEN_BUILD_LINE}" ]; then
      ZOPEN_LOG_DIR="${ZOPEN_LOG_DIR}.${ZOPEN_BUILD_LINE}"
    fi
  fi

  [[ -d ${ZOPEN_LOG_DIR} ]] || mkdir -p ${ZOPEN_LOG_DIR}

  if [ "${ZOPEN_BOOTSTRAP}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_BOOTSTRAP})" ]; then
    export ZOPEN_BOOTSTRAP_CMD="\"${ZOPEN_BOOTSTRAP}\" ${ZOPEN_BOOTSTRAP_OPTS}"
  else
    unset ZOPEN_BOOTSTRAP_CMD
  fi

  if [ -z "${ZOPEN_CONFIGURE_OPTS}" ]; then
    case "${ZOPEN_CONFIGURE}" in
    *cmake*)
      export ZOPEN_CONFIGURE_OPTS="--install-prefix ${ZOPEN_INSTALL_DIR} ${ZOPEN_EXTRA_CONFIGURE_OPTS}"
      ;;
    *)
      export ZOPEN_CONFIGURE_OPTS="--prefix=${ZOPEN_INSTALL_DIR} ${ZOPEN_EXTRA_CONFIGURE_OPTS}"
      ;;
    esac
  fi
  if [ "${ZOPEN_CONFIGURE}x" != "skipx" ]; then
    if [ -z "${ZOPEN_CONFIGURE_MINIMAL}" ]; then
      case "${ZOPEN_CONFIGURE}" in
      *cmake*)
        export ZOPEN_CONFIGURE_CMD="\"${ZOPEN_CONFIGURE}\" ${ZOPEN_CONFIGURE_OPTS} -DCMAKE_C_COMPILER=${CC} -DCMAKE_C_FLAGS=\"${CPPFLAGS} ${CFLAGS}\" -DCMAKE_CXX_COMPILER=${CXX} -DCMAKE_CXX_FLAGS=\"${CPPFLAGS} ${CXXFLAGS}\" -DCMAKE_CXX_LINK_LIBRARY_FLAG=\"${LDFLAGS}\" -DCMAKE_C_LINK_LIBRARY_FLAG=\"${LDFLAGS}\" -DCMAKE_CXX_STANDARD_LIBRARIES=\"${LIBS}\" -DCMAKE_C_STANDARD_LIBRARIES=\"${LIBS}\""
        ;;
      *)
        export ZOPEN_CONFIGURE_CMD="\"${ZOPEN_CONFIGURE}\" ${ZOPEN_CONFIGURE_OPTS} CC=${CC} CPPFLAGS=\"${CPPFLAGS}\" CFLAGS=\"${CFLAGS}\" CXX=${CXX} CXXFLAGS=\"${CXXFLAGS}\" LDFLAGS=\"${LDFLAGS}\" LIBS=\"${LIBS}\" LDLIBS=\"${LIBS}\""
        ;;
      esac
      export ZOPEN_CONFIGURE_MINIMAL="no"
    else
      export ZOPEN_CONFIGURE_CMD="\"${ZOPEN_CONFIGURE}\" ${ZOPEN_CONFIGURE_OPTS}"
      export ZOPEN_CONFIGURE_MINIMAL="yes"
    fi
  else
    unset ZOPEN_CONFIGURE_CMD
    unset ZOPEN_CONFIGURE_MINIMAL_CMD
  fi

  verboseOpts=""
  if [ "${VERBOSE}" -eq 1 ]; then
    verboseOpts="V=1"
  fi

  if [ "${ZOPEN_MAKE}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_MAKE})" ]; then
    if [ -z "${ZOPEN_MAKE_MINIMAL}" ]; then
      export ZOPEN_MAKE_CMD="\"${ZOPEN_MAKE}\" ${ZOPEN_MAKE_OPTS} ${verboseOpts} CC=${CC} \"CPPFLAGS=${CPPFLAGS}\" \"CFLAGS=${CFLAGS}\" CXX=${CXX} \"CXXFLAGS=${CXXFLAGS}\" \"LDFLAGS=${LDFLAGS}\" \"LDLIBS=${LIBS}\""
      export ZOPEN_MAKE_MINIMAL="no"
    else
      export ZOPEN_MAKE_CMD="\"${ZOPEN_MAKE}\" ${ZOPEN_MAKE_OPTS}"
      export ZOPEN_MAKE_MINIMAL="yes"
    fi
  else
    unset ZOPEN_MAKE_CMD
  fi

  if [ "${ZOPEN_CHECK}x" != "skipx" ] && ! ${skipcheck}; then
    if [ -z "${ZOPEN_CHECK_MINIMAL}" ]; then
      export ZOPEN_CHECK_CMD="\"${ZOPEN_CHECK}\" ${ZOPEN_CHECK_OPTS} ${verboseOpts} CC=${CC} \"CPPFLAGS=${CPPFLAGS}\" \"CFLAGS=${CFLAGS}\" CXX=${CXX} \"CXXFLAGS=${CXXFLAGS}\" \"LDFLAGS=${LDFLAGS}\""
    else
      export ZOPEN_CHECK_CMD="\"${ZOPEN_CHECK}\" ${ZOPEN_CHECK_OPTS}"
    fi
    export ZOPEN_CHECK_RESULTS_CMD="\"${ZOPEN_CHECK_RESULTS_CODE}\" \"${ZOPEN_LOG_DIR}\" \"${LOG_PFX}\""
  else
    unset ZOPEN_CHECK_CMD
    unset ZOPEN_CHECK_RESULTS_CMD
  fi

  if [ "${ZOPEN_INSTALL}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_INSTALL})" ]; then
    case "${ZOPEN_CONFIGURE}" in
    *cmake*)
      export ZOPEN_INSTALL_CMD="\"${ZOPEN_INSTALL}\" ${ZOPEN_INSTALL_OPTS}"
      ;;
    *)
      export ZOPEN_INSTALL_CMD="\"${ZOPEN_INSTALL}\" ${ZOPEN_INSTALL_OPTS} ${verboseOpts} CC=${CC} \"CPPFLAGS=${CPPFLAGS}\" \"CFLAGS=${CFLAGS}\" CXX=${CXX} \"CXXFLAGS=${CXXFLAGS}\" \"LDFLAGS=${LDFLAGS}\""
      ;;
    esac
    [[ -d ${ZOPEN_ROOT}/install ]] || mkdir -p ${ZOPEN_ROOT}/install
    paxFileName="${ZOPEN_ROOT}/install/${ZOPEN_NAME}.${LOG_PFX}.zos.pax.Z"
    export ZOPEN_PAX_CMD="pax -w -z -x pax \"-s#${ZOPEN_INSTALL_DIR}/#${ZOPEN_NAME}/#\" -f \"${paxFileName}\" \"${ZOPEN_INSTALL_DIR}/\""
  else
    unset ZOPEN_INSTALL_CMD
    unset ZOPEN_PAX_CMD
  fi

  if [ "${ZOPEN_CLEAN}x" != "skipx" ] && [ ! -z "$(command -v ${ZOPEN_CLEAN})" ]; then
    export ZOPEN_CLEAN_CMD="\"${ZOPEN_CLEAN}\" ${ZOPEN_CLEAN_OPTS}"
  else
    unset ZOPEN_CLEAN_CMD
  fi

  return 0
}

generateOCI()
{
  if ! ${publishOCI}; then
    return 0
  fi
  printHeader "Generating OCI Image"
  package=$1
  name=$(echo ${package} | cut -d "-" -f 1)
  version=$(echo ${package} | cut -d "-" -f 2)

  # Make the version OCI compat
  case "${version}" in
  *.*.*.*) ;;
  *.*.*) version="${version}.0" ;;
  *.*) version="${version}.0.0" ;;
  *) version="1.0.0.0" ;;
  esac

  dockerfilecontents="
FROM scratch

LABEL name=${name}
LABEL vendor=OSS
LABEL version=${version}
LABEL specification=1.0.0"

  cd ${ZOPEN_INSTALL_DIR} || exit
  if [ -f "${ZOPEN_IMAGE_DOCKERFILE_NAME}" ]; then
    rm -f "${ZOPEN_IMAGE_DOCKERFILE_NAME}"
  fi
  printVerbose "Generating ${ZOPEN_IMAGE_DOCKERFILE_NAME}"
  for file in *; do
    dockerfilecontents="${dockerfilecontents}\nCOPY ${file} @{CONTAINER_READWRITE}/${file}"
  done

  # Add required .env file
  mkdir -p .zpm
  cp .env .zpm/.env
  dockerfilecontents="${dockerfilecontents}\nCOPY .zpm @{CONTAINER_READWRITE}/.zpm"

  if ! asciiecho "${dockerfilecontents}" "${ZOPEN_IMAGE_DOCKERFILE_NAME}"; then
    printError "Unable to make ${ZOPEN_IMAGE_DOCKERFILE_NAME}"
  fi

  if [ -z ${ZOPEN_IMAGE_REGISTRY} ]; then
    printWarning "Environment variable ZOPEN_IMAGE_REGISTRY is needed to push an OCI image"
    return 4
  fi
  if [ -z ${ZOPEN_IMAGE_REGISTRY_ID} ]; then
    printWarning "Environment variable ZOPEN_IMAGE_REGISTRY_ID is needed to push an OCI image"
    return 4
  fi
  if [ -z ${ZOPEN_IMAGE_REGISTRY_KEY_FILE} ] || [ ! -r ${ZOPEN_IMAGE_REGISTRY_KEY_FILE} ]; then
    printWarning "Environment variable ZOPEN_IMAGE_REGISTRY_KEY_FILE is needed to push an OCI image"
    return 4
  fi
  if [ -z "$(command -v ${ZOPEN_IMAGE_DOCKER_NAME})" ]; then
    printWarning "${ZOPEN_IMAGE_DOCKER_NAME} is not present on your system"
    return 4
  fi
  printVerbose "Generating OCI Image"
  "${ZOPEN_IMAGE_DOCKER_NAME}" build -t "${name}:${version}" .
  "${ZOPEN_IMAGE_DOCKER_NAME}" push "${name}:${version}" -i ${ZOPEN_IMAGE_REGISTRY} -u ${ZOPEN_IMAGE_REGISTRY_ID} -p @${ZOPEN_IMAGE_REGISTRY_KEY_FILE}
  cd - || exit
}

generateZOSLIBHooks()
{
  # Background:
  #  As part of the build/install process, various tools may require application specific environment variables to be set.
  #  This function generates a C hook zoslib_env_hook() that will be called by ZOSLIB before main is entered.
  #  The function's purpose is to automatically set environment variables before main.
  #  Taking Git as an example, unless Git is installed in the standard location, (e.g. /usr/local/zopen),
  #  it has a requirement to set the following environment variables, GIT_TEMPLATE_DIR, GIT_EXEC_PATH, and
  #  GIT_SSL_CAINFO.
  #  This function takes input from zopen_append_to_zoslib_env. For Git, this looks like:
  # GIT_TEMPLATE_DIR|set|PROJECT_ROOT/share/git-core/templates
  # GIT_EXEC_PATH|set|PROJECT_ROOT/libexec/git-core
  # GIT_SSL_CAINFO|set|PROJECT_ROOT/cacert.pem
  #  The first field is the environment variable. The second field is the action, which is one of set (if unset), unset, overrideset or prepend.
  #  The last field is the value. For unset, this is left empty. PROJECT_ROOT is replaced by the root directory of where the project is installed to.

  zoslib_env=""
  #TODO: In the future, consider locating all shared libraries and adding the LIBPATH automatically
  #zoslib_env="PATH|prepend|PROJECT_ROOT/bin
  #LIBPATH|prepend|PROJECT_ROOT/lib
  #"

  if [ -z "${CC}" ]; then
    printVerbose "Skipping GenerateZOSLIBHooks since CC is not set"
    return
  fi

  if ! command -v "${CC}" > /dev/null 2>&1; then
    printVerbose "Skipping GenerateZOSLIBHooks since CC is not a command"
    return
  fi

  if command -V "${ZOPEN_APPEND_TO_ZOSLIB_ENV_CODE}" > /dev/null 2>&1; then
    printVerbose "Appending additional environment zoslib variables..."
    zoslib_env="${zoslib_env}$(${ZOPEN_APPEND_TO_ZOSLIB_ENV_CODE})"
  fi

  printHeader "Generating ZOSLIB Environment Hooks"

  # Generate directories
  mkdir -p .zoslib_hooks
  cd .zoslib_hooks || exit

  output="zoslib_env_hook.c"

  commit="local"
  if [ -n "$ZOPEN_COMMIT_SHA" ]; then
    commit="$(git rev-parse HEAD | cut -c -7)" # shorten to 7 chars for iden
  fi

  if [ -z "$ZOPEN_VENDOR" ]; then
    ZOPEN_VENDOR="zOS_Open_Tools" 
  fi

  iden="\$Id: Vendor:$ZOPEN_VENDOR BuildRev:$commit $(/bin/date +"%Y-%m-%d %H:%M:%S %Z") \$";

  # Defines zoslib_env_hook
  cat << zz > "${output}"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma convert("IBM-1047")
char __zopen_identifier[] = "$iden";
#pragma convert(pop)

#define PROJECT_ROOT_STR "PROJECT_ROOT"

__attribute__((visibility("default"))) int zoslib_env_hook(char*) __attribute__((used));

__attribute__((visibility("default"))) int zoslib_env_hook(char* root_dir) {
char* envar_value;
char* value_str;
char* pos;
long size;

// Avoid setting environment variables during build time because they do not hold correct values
// and should only be used from the installed location.
// To avoid setting environment variables during build time, we need to guard it
// by checking if ZOPEN_IN_ZOPEN_BUILD is set to the current build process setting.
// But this also meant that any dependent tools that set envars via zoslib env hooks would avoid setting those environment variables, effectively breaking them.
if ((envar_value = getenv("ZOPEN_IN_ZOPEN_BUILD")) &&
    strcmp(envar_value, "${ZOPEN_IN_ZOPEN_BUILD}") == 0) {
  return 0;
}
zz

  # Process input
  if [ -n "${zoslib_env}" ]; then
  echo "${zoslib_env}" | while read line; do
    # If its a comment, skip the line
    if [ "${line}" != "${line#\#}" ]; then
        continue
    fi
    # The line is of this form (no spaces allowed):
    # some var|some action|some value
    #        |set|
    #        |overrideset|
    if [ $(echo "${line}" | awk -F '|' '{print NF-1}') -ne 2 ]; then
      printError "${line} must have 2 '|' seperators only"
    fi
    var=$(echo ${line} | cut -d '|' -f 1)
    action=$(echo ${line} | cut -d '|' -f 2)
    value=$(echo ${line} | cut -d '|' -f 3)
    projectRootCount=$(echo "${value}" | awk -F "PROJECT_ROOT" '{print NF-1}')

    if [ "${action}" = "unset" ]; then
      echo "unsetenv(\"${var}\");" >> "${output}"
    elif [ "${action}" = "set" -o "${action}" = "overrideset" ]; then
      forceset="0"
      if [ "${action}" = "overrideset" ]; then
        forceset="1";
      fi
      cat << zz >> "${output}"
    value_str = "${value}";
    size = PATH_MAX;
    envar_value = (char*)malloc(size);
    memset(envar_value, 0, size);

    while (1) {
      pos = strstr(value_str, PROJECT_ROOT_STR);
      if (pos != NULL) {
        size_t length_before_project_root = pos - value_str;
        strncat(envar_value, value_str, length_before_project_root);
        strcat(envar_value, root_dir);
        value_str = pos + sizeof(PROJECT_ROOT_STR) - 1;
      } else {
        strcat(envar_value, value_str);
        break;
      }
    }

    if (!getenv("${var}") || ${forceset}) {
      if (getenv("__ZOPEN_DEBUG"))
        fprintf(stderr, "Setting variable %s=%s\n", "${var}", envar_value);
      if (setenv("${var}", envar_value, 1) != 0) {
        fprintf(stderr, "Error: Setting environment variable %s=%s\n", "${var}", envar_value);
        exit(1);
      }
    }
    free(envar_value);
zz
    elif [ "${action}" = "prepend" ]; then
      cat << zz >> "${output}"
    value_str = "${value}";
    size = strlen(getenv("${var}")) + strlen(value_str) + strlen(root_dir)*${projectRootCount} + 2 /*for : and null*/;
    envar_value = (char*)malloc(size);
    memset(envar_value, 0, size);

    // Substitute PROJECT_ROOT with root_dir (actual project directory)
    while (1) {
      pos = strstr(value_str, PROJECT_ROOT_STR);
      if (pos != NULL) {
        size_t length_before_project_root = pos - value_str;
        strncat(envar_value, value_str, length_before_project_root);
        strcat(envar_value, root_dir);
        value_str = pos + sizeof(PROJECT_ROOT_STR) - 1;
      } else {
        strcat(envar_value, value_str);
        break;
      }
    }

    strcat(envar_value, ":");
    strcat(envar_value, getenv("${var}"));
    if (getenv("__ZOPEN_DEBUG"))
      fprintf(stderr, "Prepending variable %s=%s\n", "${var}", envar_value);
    if (setenv("${var}", envar_value, 1) != 0) {
      fprintf(stderr, "Error: prepending environment variable %s=%s\n", "${var}", envar_value);
      exit(1);
    }
    free(envar_value);
zz
    else
      printError "${action} is not valid, must be one of set, unset, or prepend"
    fi

  done
  fi

  echo "" >> "${output}"
  echo "return 0;" >> "${output}"
  echo "}" >> "${output}"

  # xlclang pragma linkage does not work
  if [ "${CC}" = "xlclang" ]; then
    extraOptions="-qexportall"
  fi

  if ! runAndLog "${CC} ${CFLAGS} ${CPPFLAGS} -DPATH_MAX=1024 ${extraOptions} -c ${output} -o ${output}.o"; then
    printError "Compiler command for ${output} failed to compile"
  fi

  # Apply it in both LIB envars because some ports use ZOPEN_EXTRA_LIBS directly
  export ZOPEN_EXTRA_LIBS="${ZOPEN_EXTRA_LIBS} ${PWD}/${output}.o"
  export LIBS="${LIBS} ${PWD}/${output}.o"

  cd ..
}

#
# Start of 'main'
#

if ! setDefaults; then
  exit 4
fi

if ! processOptions $*; then
  exit 4
fi

export ZOPEN_ROOT=$(
  cd "$(dirname "${buildEnvFile}")" || exit
  pwd
)

if ! loadBuildEnv; then
  exit 4
fi

if ! checkEnv; then
  exit 4
fi

if ! setEnv; then
  exit 4
fi

if ! getCode; then
  exit 4
fi

if command -V "zopen_pre_patch" > /dev/null 2>&1; then
  printVerbose "Running zopen_pre_patch"
  "zopen_pre_patch" "${PWD}"
fi

if ! applyPatches; then
  exit 4
fi

if ${getSourceOnly}; then
  exit 0
fi

cd "${ZOPEN_ROOT}/${dir}" || exit 99

if [ -n "${ZOPEN_SRC_DIR}" ]; then
  cd "${ZOPEN_SRC_DIR}" || exit 99
fi

if [ -z "${ZOPEN_SKIP_ZOSLIB_ENV_HOOK}" ]; then
  generateZOSLIBHooks
fi

if ! resolveCommands; then
  exit 4
fi

if command -V "${ZOPEN_INIT_CODE}" > /dev/null 2>&1; then
  printVerbose "Running ${ZOPEN_INIT_CODE}"
  "${ZOPEN_INIT_CODE}" "${PWD}"
fi

if ${startShell}; then
  if [ -n "${ZOPEN_SHELL}" ]; then
    exec "${ZOPEN_SHELL}"
  else
    exec /bin/sh
  fi
fi

if ${cleanupBuild} || ${forceRebuild} || ${freshBuild}; then
  cleanup
  if ${cleanupBuild}; then
    exit 0
  fi
fi

if ! bootstrap; then
  exit 4
fi

if ! configure; then
  exit 4
fi

if ! build; then
  exit 4
fi

if ! check; then
  exit 4
fi

if ! install; then
  exit 4
fi

if command -V "${ZOPEN_PRE_TERMINATE_CODE}" > /dev/null 2>&1; then
  printVerbose "Running ${ZOPEN_PRE_TERMINATE_CODE}"
  if ! "${ZOPEN_PRE_TERMINATE_CODE}" "${ZOPEN_INSTALL_DIR}"; then
    printError "Pre terminate failed."
  fi
fi

exit 0
