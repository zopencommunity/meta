#!/bin/sh 
#
# Query utility for zopen community - https://github.com/zopencommunity
#

#
# All zopen-* scripts MUST start with this code to maintain consistency.
#
setupMyself()
{
  ME=$(basename $0)
  MYDIR="$(cd "$(dirname "$0")" > /dev/null 2>&1 && pwd -P)"
  INCDIR="${MYDIR}/../include"
  if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
    echo "Internal Error. Unable to find common.sh file to source." >&2
    exit 8
  fi
  # shellcheck source=/dev/null
  . "${INCDIR}/common.sh"
}
setupMyself

filter_implemented=false
upgradeable_implemented=false
whatprovides_implemented=false

printHelp(){
  cat << HELPDOC
zopen query -  a utility for zopen community to query packages and repos.

Usage: zopen query [OPTION] [VERB] [PACKAGE]

Options:
  -d, --details     include full details for listings
  -i, --installed   list only installed z/OS Open Tools
      --list        list all available z/OS Open Tools
      --no-header   suppress the header for the output
      --no-version  suppress version information, return package names
      --remote-search
                    regex match package against available packages
      --verbose     run in verbose mode
      --version     print version
  -h,-?, --help     display this help and exit
HELPDOC
if ${filter_implemented}; then
  echo "  --filter COLOR   apply COLOR (quality) filter."
  echo "                   green: all pass, blue: most pass, yellow: some pass, red: no pass, gray: skipped"
fi
if ${upgradeable_implemented}; then
  echo "  --upgradeable    list packages where an upgrade is available."
fi
if ${whatprovides_implemented}; then
  echo "  -wp, --whatprovides  which installed package provided a file."
fi
  echo ""
  echo "Options:"
  echo "  -d, --details    include full details for listings."
if ${filter_implemented}; then
  echo "  --filter COLOR   apply COLOR (quality) filter."
  echo "                   green: all pass, blue: most pass, yellow: some pass, red: no pass, gray: skipped"
fi
  echo "  --category <category> apply a category filter."
  echo "  --help           print this help"
  echo "  --no-header,     suppress the header for the output."
  echo "  --no-version,    suppress version information, return package names."
  echo "  -v               run in verbose mode."
  echo "  --version        print version"
}

colorizepct()
{
  percentage=$1
  if [ -z "${percentage}" ]; then
    colored="${RED}"
  elif [ ! "${percentage}" = "${percentage#Skipped}" ]; then
    colored="${GRAY}"
  elif [ ${percentage} -eq 100 ]; then
    colored="${GREEN}"
  elif [ ${percentage} -gt 50 ]; then
    colored="${BOLD}${BLUE}"
  elif [ ${percentage} -gt 0 ]; then
    colored="${YELLOW}"
  else
    colored="${RED}"
  fi
  echo "${colored}"
}

printDetailListEntries()
{
  details=$1
  needle=$2
  onlyUpgradesAvailable=$3

  if [ "${details}" -eq 0 ]; then
    scrcols=$(getScreenCols)
    numcols=5
    colwidth=$((scrcols / numcols - 1))
    printVerbose "Screen width: ${scrcols}; colwidth:${colwidth}"
    if [ ! -z "$1" ] && ! ${noheader}; then
      printf "${NC}${UNDERLINE}%-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s${NC}\n" "Package" "Installed" "Available" "Latest Tag" "Categories"
    fi
    echo "${repoArray}" | xargs | tr ' ' '\n' | sort | while read repo; do
      listport=false
      if [ -z "${needle}" ]; then
        listport=true
      else
        printVerbose "Attempting regex find with needle: '${needle}'"
        if expr "${repo}" : "${needle}" 1> /dev/null; then
          listport=true
        fi
      fi

      if ${listport}; then
        latest=$(jq -e -r '.release_data."'${repo}'"[0]' "${JSON_CACHE}")
        if [ $? -ne 0 ]; then
          printError "Unable to retrieve remote information"
        fi
        latestVersion=$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].name' | sed -E 's/.*-(.*)\.zos\.pax\.Z/\1/')
        categories=$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].categories')
        if [ -n "${category_filter}" ] && ! echo "${categories}" | grep -q "${category_filter}"; then
          continue
        fi
        pkghome="${ZOPEN_PKGINSTALL}/${repo}/${repo}"
        if [ -e "${pkghome}/.releaseinfo" ]; then
          originalVersion=$(cat "${pkghome}/.releaseinfo")
        else
          originalVersion="Not installed"
        fi
        if [ -e "${pkghome}/.version" ]; then
          dotversion=$(cat "${pkghome}/.version")
        else
          dotversion="N/A"
        fi
        if [ "${onlyUpgradesAvailable}" -gt 0 ]; then
          if [ "${originalVersion}" = "Not installed" -o "${originalVersion}" = "${latestVersion}" ]; then
            continue
          fi
        fi
        if ! ${noversion}; then
          printf "%-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s\n" "${repo}" "${originalVersion}" "${dotversion}" "${latestVersion}" "${categories}"
        else
          printf "%s\n" "${repo}"
        fi
      fi
    done
  else
    printVerbose "Checking repoArray: ${repoArray}"
    scrcols=$(getScreenCols)
    numcols=7
    colwidth=$((scrcols / numcols - 1))
    printVerbose "Screen width: ${scrcols}; colwidth:${colwidth}"
    if ! ${noheader}; then
      printf "${NC}${UNDERLINE}%-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s${NC}\n" "Package" "Installed" "Latest Tag" "Download Size" "Expanded Size" "Quality" "Categories"
    fi
    echo "${repoArray}" | xargs | tr ' ' '\n' | sort | while read repo; do
      listport=false
      if [ -z "${needle}" ]; then
        listport=true
      else
        printVerbose "Attempting regex find with needle: '${needle}'"
        if expr "${repo}" : "${needle}" 1> /dev/null; then
          listport=true
        fi
      fi

      if ${listport}; then
        pkghome="${ZOPEN_PKGINSTALL}/${repo}/${repo}"
        if [ -e "${pkghome}/.releaseinfo" ]; then
          originalTag=$(cat "${pkghome}/.releaseinfo")
        else
          originalTag="Not installed"
        fi
        latest=$(jq -e -r '.release_data."'${repo}'"[0]' "${JSON_CACHE}")
        case $? in
        1)
          printVerbose "No latest release for port"
          printf "%-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s %-${colwidth}s ${NC}${RED}%-${colwidth}s %-${colwidth}s${NC}\n" "${repo}" "${originalTag}" "Unknown" "Unknown" "Unknown" "Unknown" "Unknown"
          ;;
        0)
          printVerbose "Latest release request successful"
          latestTag="$(/bin/printf "%s" "${latest}" | jq -e -r '.tag_name')"
          passed="$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].passed_tests')"
          total="$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].total_tests')"
          expandedsize="$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].expanded_size')"
          downloadsize="$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].size')"
          categories=$(/bin/printf "%s" "${latest}" | jq -e -r '.assets[0].categories')
          if [ "${onlyUpgradesAvailable}" -gt 0 ]; then
            if [ "${originalTag}" = "Not installed" -o "${originalTag}" = "${latestTag}" ]; then
              continue
            fi
          fi
          if [ -n "$total" ] && [ ${total} -gt 0 ]; then
            percentage=$(echo "scale=0; 100 * (${passed}) / ${total}" | bc)
          fi
          /bin/printf "%-${colwidth}s %-${colwidth}s %-${colwidth}s" "${repo}" "${originalTag}" "${latestTag}"
          /bin/printf " %-${colwidth}s" "${downloadsize}"
          /bin/printf " %-${colwidth}s" "${expandedsize}"

          if [ -z "${percentage}" ]; then
            /bin/printf "${NC}${RED}%-${colwidth}s${NC}" "No tests"
          else
            /bin/printf "${NC}$(colorizepct "${percentage}")%-${colwidth}s${NC}" "${percentage}"
          fi
          /bin/printf " %-${colwidth}s" "${categories}"
          /bin/printf "\n"
          ;;
        *) printError "Error while trying to retrieve latest repo release" ;;
        esac

      fi
      continue
    done
  fi
  exit 0
}

whatProvides()
{
  needle="$1"
  printVerbose "Finding matches outside of ZOPEN_PKGINSTALL (${ZOPEN_PKGINSTALL})"
  # Find any symlinks that match the needle and can then be dereferenced
  found=$(zosfind "${ZOPEN_ROOTFS}" -name "${ZOPEN_PKGINSTALL}/\*" -prune -o -type l -print | grep "${needle}")
  printVerbose "Found list: '${found}'"
  if [ -z "${found}" ]; then
    printInfo "No package provides '${needle}'"
  else
    matches=$(echo "${found}" | wc -w | tr -d ' ')
    printInfo "Found ${matches} match$([ ${matches} = 1 ] && echo "" || echo "es") for regex '${needle}' on the system"
    echo "${found}" | xargs | tr ' ' '\n' | while read foundmatch; do
      printVerbose "Parsing '${foundmatch}'"
      if [ ! -d "${foundmatch}" ]; then
        dereferenced=$(deref "${foundmatch}")
        fullpackage=$(echo "${dereferenced}" | sed "s#${ZOPEN_PKGINSTALL}/\([^/]*\).*#\1#")

        printInfo "Package '${fullpackage}' provides: '${foundmatch}'"
      fi
    done
  fi
  exit 0
}

# Main code start here
args=$*
verbose=false
noheader=false
noversion=false
localoption=true
upgradeable=false
list=false
unset category_filter
details=0
needle=
if [ $# -eq 0 ]; then
  printError "No option provided for query"
fi

while [ $# -gt 0 ]; do
  printVerbose "Parsing option: $1"
  case "$1" in
  "--list")
    list=true
    localoption=false
    ;;
  "-i" | "--installed")
    localoption=true
    installed=1
    list=true
    ;;
  "-wp" | "--whatprovides")
    localoption=true
    whatprovides=1
    shift
    [ -n "$1" ] || printError "Missing file argument"
    needle=$1
    ;;
  "--remote-search")
    localoption=false
    remotesearch=1
    shift
    [ -n "$1" ] || printError "Missing package argument"
    needle=$1
    ;;
  "--no-header")
    noheader=true
    ;;
  "--upgradeable")
    upgradeable=true
    ;;
  "--no-version")
    noversion=true
    noheader=true # headers do not mean anything without versions!
    ;;
  "-f" | "--filter")
    filter=$2
    shift
    ;;
  "--category")
    category_filter=$2
    shift
    ;;
  "-d" | "--details")
    details=1
    ;;
  "-h" | "--help" | "-?")
    printHelp
    exit 0
    ;;
  "--version")
    zopen-version "${ME}"
    exit 0
    ;;
  "--verbose")
    # shellcheck disable=SC2034
    verbose=true
    ;;
  "--xdebug")
    set -x
    ;;
  -*)
    printError "Unknown option '$1'"
    ;;

  *)
    chosenRepos="${chosenRepos} $1"
    ;;
  esac
  shift
done

checkIfConfigLoaded

export SSL_CERT_FILE="${ZOPEN_CA}"
export GIT_SSL_CAINFO="${ZOPEN_CA}"
export CURL_CA_BUNDLE="${ZOPEN_CA}"

if ${filter_implemented}; then
  if [ ! -z "${filter}" ]; then
    filter=$(echo "${filter}" | awk '{print tolower($0)}')
    case "${filter}" in
    blue | green | yellow | red | gray) ;;
    *) printError "The filter must be one of blue|green|yellow|red|gray" ;;
    esac
  fi
fi

if ! ${localoption}; then
  # Retrieve all repositories
  getRepos
  grfgRc=$?
  [ 0 -ne "${grfgRc}" ] && exit "${grfgRc}"
  repoArray="${repo_results}"
fi

# Use dedicated zopen-list script for listing system packages, passing
# appropriate parameters to mimic the old query behaviour
if ${list}; then
  if ${installed}; then
    if [ "${details}" -eq 0 ]; then
      (zopen list --installed)
    else
      (zopen list --installed --details --header)
    fi
  else
    (zopen list )
  fi
else
  ! ${upgradeable} || printDetailListEntries "${details}" "" 1
  [ -z "${remotesearch}" ] || printDetailListEntries "${details}" "${needle}" 0
  [ -z "${whatprovides}" ] || whatProvides "${needle}"
fi