#!/bin/sh
#
# List utility for z/OS Open Tools - https://github.com/ZOSOpenTools
#

#
# All zopen-* scripts MUST start with this code to maintain consistency.
#
setupMyself()
{
  ME=$(basename $0)
  MYDIR="$(cd "$(dirname "$0")" > /dev/null 2>&1 && pwd -P)"
  INCDIR="${MYDIR}/../include"
  if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
    echo "Internal Error. Unable to find common.sh file to source." >&2
    exit 8
  fi
  # shellcheck source=/dev/null
  . "${INCDIR}/common.sh"
}
setupMyself

printHelp(){
  cat << HELPDOC
zopen list -  list information about local packages

Usage: zopen list [OPTION] [VERB] [PACKAGE]

Options:
  --available     lists all available z/OS Open Tools
  --installed     list only installed z/OS Open Tools (default output)
  --details       provide version information on packages
  --full          provides more information about packages
  --[no]header    output explanation header for columns
  --verbose       run in verbose mode
  --version       print version
  --version-info  lists version information for installed packages when
                  combined with the --installed option
  -h,-?, --help     display this help and exit

Examples:
  zopen list --installed
                    list packages installed on the system

Report bugs at https://github.com/ZOSOpenTools/meta/issues .

HELPDOC
}

listLatestForInstalled()
{
  wpackage=20
  wversion=12
  wrelease=14
  wtag=36
  # wurl=11 Note required unless additional columns added
  if ${header}; then
    printf "${NC}${UNDERLINE}%-${wpackage}s%-${winstalled}s%-${wtag}s%-${wdownload}s%-${wexpsz}s%-${wqual}s${NC}\n" \
        "$(text_center "Package")" "$(text_center "Version")" "$(text_center "Release")"\
        "$(text_center "Tag Name")" "$(text_center "Download URL")" 
  fi
  pdb="${ZOPEN_ROOTFS}/var/lib/zopen/packageDB.json"
  installed=$(zopen list --installed | awk -v ORS=',' '{print "\""$0"\""}')
  installed="[${installed%,}]" # wrap in a JSON array and strip any trailing ',' char
  jq --raw-output --argjson installed "${installed}" \
    "$(jqfunctions) .release_data| 
    to_entries |sort_by(.key) | .[] | 
    .key as \$key | 
    select( \$installed | index(\$key)) |
    .value[0].assets[0] as \$va | 
    \$va.url as \$url | 
    (\$url | match(\".*-([^-]*).([0-9]{8}_[0-9]{6}).zos.pax.Z\").captures) as \$caps |
    \$caps[0].string as \$version |
    \$caps[1].string as \$release |
    .value[0].tag_name as \$tn |
    pr(\$key;\"@\";${wpackage}) +
     pr(\$version;\"@\"; ${wversion}) +
     pr(\$release;\"@\"; ${wrelease}) +
     pr(\$tn;\"@\";${wtag}) +
     \$url " 
      "${JSON_CACHE}" | sed 's/@/ /g'
}

listAvailablePackages()
{
  downloadJSONCache
  wpackage=20
  wversion=23
  winstalled=10
  wtag=36
  wrellne=12
  wdownload=10
  wexpsz=10
  wqual=7
  if ${urlinclude}; then
    wurl=6
    urltext="URL"
  else
    wurl=0
    urltext=""
  fi
  if ${header}; then
    if ${details} || ${full}; then
      printf "${NC}${UNDERLINE}%-${wpackage}s%-${winstalled}s%-${wtag}s%-${wdownload}s%-${wexpsz}s%-${wqual}s%-${wurl}s${NC}\n" \
          "$(text_center "Package")" "$(text_center "Installed")" "$(text_center "Latest Tag")"\
          "$(text_center "Download size")" "$(text_center "Disk usage")" "$(text_center "Quality")" \
          "$(text_center "${urltext}")"

    else
      printf "${NC}${UNDERLINE}%-${wpackage}s%-${winstalled}s%-${wversion}s%-${wtag}s${NC}\n" \
          "$(text_center "Package")" "$(text_center "Installed")" "$(text_center "Version")" "$(text_center "Latest Tag")"
    fi
  fi
  installed=$(zopen list --installed | awk -v ORS=',' '{print "\""$0"\""}')
  installed="[${installed%,}]" # wrap in a JSON array and strip any trailing ',' char

  if ${details} || ${full}; then
    if ${urlinclude}; then
      urltext='$url'
    else
      urltext=""
    fi
    jq --raw-output --argjson installed "${installed}" \
      --arg wpackage "${wpackage}" \
      --arg winstalled "${winstalled}" \
      --arg wtag "${wtag}" \
      --arg wdownload "${wdownload}" \
      --arg wexpsz "${wexpsz}" \
      --arg wqual "${wqual}" \
      --arg urltext "${urltext}" \
      "$(jqfunctions)"' .release_data|
        to_entries |sort_by(.key) | .[] |
        .key as $key |
        .value[0].assets[0] as $va |
        $va.url as $url |
        ($url | match(".*-([^-]*).[0-9]{8}_[0-9]{6}.zos.pax.Z").captures[0].string) as $version |
        .value[0].tag_name as $tn |
        (if ($installed | index($key)) then "installed" else "available" end) as $ins |
        $va.expanded_size as $es |
        $va.size as $ds |
        ($va.passed_tests | if (.=="") then "0" else . end | tonumber) as $pt |
        ($va.total_tests | if (.=="") then "99999" else . end |tonumber) as $tt |
        (($pt/$tt*100|r(2))|tostring + "%") as $q |
        pr($key;"@";($wpackage | tonumber)) +
         c($ins;"@";($winstalled | tonumber)) +
         c($tn;"@";($wtag | tonumber)) +
         c($ds;"@";($wdownload | tonumber)) +
         c($es;"@";($wexpsz | tonumber)) +
         c(($q);"@";($wqual | tonumber)) +
         $urltext ' \
      "${JSON_CACHE}" | sed 's/@/ /g'
  else
    jq --raw-output  --argjson installed "${installed}" \
      --arg wpackage "${wpackage}" \
      --arg winstalled "${winstalled}" \
      --arg wversion "${wversion}" \
      --arg wtag "${wtag}" \
      "$(jqfunctions)"' .release_data|
        to_entries |sort_by(.key) | .[] |
        .key as $key |
        .value[0].assets[0].url as $url |
        ($url | match(".*-([^-]*).[0-9]{8}_[0-9]{6}.zos.pax.Z").captures[0].string) as $version |
        .value[0].tag_name as $tn |
        (if ($installed | index($key)) then "installed" else "available" end) as $ins |
        .value[0].assets[0] as $va |
        pr($key;"@";($wpackage | tonumber)) +
         c($ins;"@";($winstalled | tonumber)) +
          c($version;"@";($wversion | tonumber)) +
           c($tn;"@";($wtag | tonumber)) ' \
      "${JSON_CACHE}" | sed 's/@/ /g'
  fi
}

listInstalledEntries()
{
  wpackage=20
  wversion=26
  wrelease=14
  wrellne=12
  wexpsz=12
  wqual=8
  if ${urlinclude}; then
    wurl=6
    urltext="URL"
  else
    wurl=0
    urltext=""
  fi
  if ${header} && ${details}; then
    if ${full}; then
      printf "${NC}${UNDERLINE}%-${wpackage}s%-${wversion}s%-${wrelease}s%-${wrellne}s%-${wexpsz}s%-${wqual}s%-${wurl}s${NC}\n" \
          "$(text_center "Package" ${wpackage})" "$(text_center "Version" ${wversion})" "$(text_center "Release" ${wrelease})" \
          "$(text_center "Releaseline" ${wrellne})" "$(text_center "Disk usage" ${wexpsz})" \
          "$(text_center "Quality" ${wqual})" "$(text_center "${urltext}" ${wurl})"
    else
      printf "${NC}${UNDERLINE}%-${wpackage}s%-${wversion}s%-${wrelease}s${NC}\n" \
          "$(text_center "Package" ${wpackage})" "$(text_center "Version" ${wversion})" "$(text_center "Release" ${wrelease})"
    fi
  fi
  pdb="${ZOPEN_ROOTFS}/var/lib/zopen/packageDB.json"
  if ! [ -e "${pdb}" ]; then
    printWarning "No package database found. Regenerating (subsequent calls will be faster)"
    updatePackageDB
  fi
  if ${details}; then
    printVerbose "Details requested"
    if ${full}; then
      printVerbose "Full details requested"
      jq --raw-output \
        --arg wpackage "${wpackage}" \
        --arg wversion "${wversion}" \
        --arg wrelease "${wrelease}" \
        --arg wrellne "${wrellne}" \
        --arg wexpsz "${wexpsz}" \
        --arg wqual "${wqual}" \
        "$(jqfunctions)"' .[] |
          keys[] as $key |
          .[$key].product.test_status as $ts |
          pr($key;"@";($wpackage | tonumber)) +
          c((.[$key].product?.version? // "unknown");"@";($wversion | tonumber)) +
          c((.[$key].product?.release? // "unknown");"@";($wrelease | tonumber)) +
          c((.[$key].product.buildline? // "unknown");"@";($wrellne | tonumber)) +
          c((.[$key].product.size? // "unknown");"@";($wexpsz | tonumber)) +
          c(((if ($ts? and ($ts.total_tests | tonumber?) and ($ts.total_success | tonumber?)) then ($ts.total_success | tonumber) / ($ts.total_tests | tonumber) else 0 end | .*100)| r(2) |tostring);"@";($wqual | tonumber))' \
        "${pdb}" | sed 's/@/ /g'
    else
      jq --raw-output \
        --arg wpackage "${wpackage}" \
        --arg wversion "${wversion}" \
        --arg wrelease "${wrelease}" \
        "$(jqfunctions)"' .[] |
          keys[] as $key |
          pr($key;"@";($wpackage | tonumber)) +
          c(.[$key].product.version;"@";($wversion | tonumber)) +
          c(.[$key].product.release;"@";($wrelease | tonumber))' \
        "${pdb}" | sed 's/@/ /g'
    fi
  elif ${versioninfo}; then
    jq --raw-output \
      --arg wpackage "${wpackage}" \
      --arg wversion "${wversion}" \
      "$(jqfunctions)"' .[] |
        keys[] as $key |
        .[$key].product.test_status as $ts |
        pr($key;"@";($wpackage | tonumber)) +
        c((.[$key].product?.version? // "unknown");"@";($wversion | tonumber))' \
      "${pdb}" | sed 's/@/ /g'
  else
    jq --raw-output \
      '[.[] | keys[] as $key | $key] | unique[] ' \
      "${pdb}"
  fi
}


# Main code start here
# Note that functions use padding chars of '@' to work round a quirk of jq in that
# it will collapse repeated spaces into tab characters - which proves irksome when tryinh
# to pad/format column layouts; '@' chars get post-processed into spaces

verbose=false
header=false
details=false
full=false
available=false
installed=true
updates=false
urlinclude=false  # whether to include download url in output information
versioninfo=false

while [ $# -gt 0 ]; do
  printVerbose "Parsing option: $1"
  case "$1" in
    "--available") available=true; installed=false; updates=false;;
    "--installed") available=false; installed=true; updates=false;;
    "--updates") available=false; installed=true; updates=true ;;
    "--details") details=true ;;
    "--full") full=true; details=true ;;
    "--header") header=true ;;
    "--noheader") header=false ;;
    "--url") urlinclude=true ;;
    "--version-info") versioninfo=true ;;
    "-h" | "--help" | "-?")
      printHelp
      exit 0
      ;;
    "--version")
      zopen-version "${ME}"
      exit 0
      ;;
    "--verbose")
      # shellcheck disable=SC2034
      verbose=true
      ;;
    "--xdebug")
      set -x
      ;;
    -*)
      printError "Unknown option '$1'"
      ;;
    *)
      chosenRepos="${chosenRepos} $1"
      ;;
  esac
  shift
done

checkIfConfigLoaded
if ${installed}; then
  listInstalledEntries
  exit 0
fi
if ${available}; then
  listAvailablePackages
  exit 0
fi


