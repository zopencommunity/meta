#!/bin/sh
#
# Install utility for zopen community - https://github.com/zopencommunity
#

#
# All zopen-* scripts MUST start with this code to maintain consistency.
#
setupMyself()
{
  ME=$(basename "$0")
  MYDIR="$(cd "$(dirname "$0")" > /dev/null 2>&1 && pwd -P)"
  INCDIR="${MYDIR}/../include"
  if ! [ -d "${INCDIR}" ] && ! [ -f "${INCDIR}/common.sh" ]; then
    echo "Internal Error. Unable to find common.sh file to source." >&2
    exit 8
  fi
  # shellcheck source=/dev/null
  . "${INCDIR}/common.sh"
}
setupMyself
checkWritable

startGPGAgent() {
  printInfo "- Starting gpg-agent..."

  SOCKET_PATH=$(gpgconf --list-dirs agent-socket)
  if [ -r "$SOCKET_PATH" ]; then
    printVerbose "gpg-agent is already running (socket found at $SOCKET_PATH)."
    return 0
  fi

  if eval "$(gpg-agent --daemon --disable-scdaemon)" >/dev/null 2>&1; then
    if [ -r "$SOCKET_PATH" ]; then
      printVerbose "gpg-agent started successfully (socket created at $SOCKET_PATH)."
    else
      printWarning "gpg-agent started, but socket was not created at $SOCKET_PATH. Please verify your GPG installation."
    fi
  else
    if [ -r "$SOCKET_PATH" ]; then
      printWarning "gpg-agent started successfully (socket created at $SOCKET_PATH), but gpg-agent returned a non-zero return code."
    else
      printError "Failed to start gpg-agent. Reinstall or upgrade GPG using \"zopen install --reinstall gpg -y\" or \"zopen upgrade gpg -y\"."
    fi
  fi
}

gpgCleanup() {
  printVerbose "Cleaning up $SIGNATURE_FILE, $PUBLIC_KEY_FILE and $TMP_GPG_DIR"
  [ -e "$SIGNATURE_FILE" ] && rm -f "$SIGNATURE_FILE"
  [ -e "$PUBLIC_KEY_FILE" ] && rm -f "$PUBLIC_KEY_FILE"
  [ -d "$TMP_GPG_DIR" ] && rm -rf "$TMP_GPG_DIR"
}

printHelp()
{
cat << HELPDOC
${ME} is a utility to download/install a zopen community package.

Usage: zopen install [OPTION] [PARAMETERS] [PACKAGES]

Options:
  --all                    download all available packages and install
  --bypass-prereq-checks   ignores pre-req checks
  --download-only          download installable package with no install
  --install-or-upgrade     installs the package if not installed, or upgrades
                           the package if installed (deprecated as default behaviour)
  --nodeps                 do not install dependencies
  --noset-active           unpackage onto the system but do not change the currently
                           active version
  --reinstall              reinstall currently installed package(s)
  --reinstall-with-deps    reinstall package(s) and their dependencies
  --release-line [stable|dev]
                           the release line to install from
  --select                 select a version to install from available versions
  -v, --verbose            run in verbose mode
  -y, --yes                automatically answer yes to prompts
  -h,-?, --help            display this help and exit


Examples:
  zopen install foo 
                    install package foo if not already installed
  zopen install --release-line DEV foo
                    install package foo from the DEV releaseline if
                    available
  zopen install -y foo bar --nodeps
                    install packages foo and bar without asking for
                    user confirmation and without installing any
                    dependencies
  zopen install /tmp/foo-1.2.3-4.zos.pax.Z
                    install package foo from the specified location
  zopen install /tmp/foo-1.2.3-4.zos.pax.Z bar-1.2.3.4.zos.pax.Z
                    install packages foo and bar from the specified 
                    locations

Report bugs at https://github.com/ZOSOpenTools/meta/issues .

HELPDOC
}

# Main code start here
# Need to set a number of variables for use in the install function
# which is common between install & upgrade
args=$*
verbose=false
debug=false
xdebug=false
quiet=false
selectVersion=false
# shellcheck disable=SC2034
bypassPrereqs=false
# shellcheck disable=SC2034
setActive=true
downloadOnly=false
reinstall=false
reinstallDeps=false
installOrUpgrade=false
# shellcheck disable=SC2034
nosymlink=false
# shellcheck disable=SC2034
skipupgrade=false
skipverify=false
doNotInstallDeps=false
all=false
yesToPrompts=false
bypassPrereqs=false
force=false
chosenRepos=""
fileinstall=false

while [ $# -gt 0 ]; do
  case "$1" in
    "-r" | "-reinstall" | "--reinstall")
      # shellcheck disable=SC2034
      reinstall=true  # If package already installed, reinstall
      ;;
    "--reinstall-with-deps")
      # shellcheck disable=SC2034
      reinstallDeps=true  # If reinstalling, also reinstall dependencies
      # shellcheck disable=SC2034
      reinstall=true
      ;;
    "--install-or-upgrade")
      # shellcheck disable=SC2034
      installOrUpgrade=true  # Upgrade package or install if not present
      ;;
    "--bypass-prereq-checks")
      bypassPrereqs=true 
      ;;
    "--no-symlink")
      # shellcheck disable=SC2034
      setactive=true  # Do not mesh the package into the file system; leave as stand-alone
      ;;
    "--nodeps" | "--no-deps") # Deprecate --no-deps for consistency
      doNotInstallDeps=true
      ;;
    "--release-line")
      shift
      # shellcheck disable=SC2034
      releaseLine=$(echo "$1" | awk '{print toupper($0)}')
      ;;
    "--yes" | "-y")
      # shellcheck disable=SC2034
      yesToPrompts=true  # Automatically answer 'yes' to any questions
      ;;
    "--download-only")
      downloadOnly=true  # Download remote package files to current directory only
      ;;
    "--noset-active" | "--no-set-active") # Deprecate --no-set-active for consistency
      # shellcheck disable=SC2034
      setactive=false  # Install package as normal but keep existing installation as active
      ;;
    "--skip-verify" | "-sv")
      # shellcheck disable=SC2034
      skipverify=true # Verify signature of packages
      ;;
    "--force")
      # shellcheck disable=SC2034
      force=true # Bypasses locks
      ;;
    "--all")
      all=true  # Install all packages
      ;;
    "--select")
      # shellcheck disable=SC2034
      selectVersion=true  # Display a selction table to allow version picking
      ;;
    "-h" | "--help" | "-?")
      printHelp "${args}"
      exit 0
      ;;
    "--debug")
      verbose=true
      # shellcheck disable=SC2034
      debug=true
      ;;
    "-v" | "--verbose")
      # shellcheck disable=SC2034
      verbose=true
      ;;
    "--xdebug")
      xdebug=true
    ;;
    "--quiet")
      # shellcheck disable=SC2034
      quiet=true
    ;;
  "--version")
    zopen-version "${ME}"
    exit 0
    ;;

  -*) printError "Unsupported parameter '$1'";;
  *)
    # Generate a long @@ separated string to allow for embedded
    # spaces in hardcoded pax filenames
    chosenRepos="${chosenRepos}@@$1"
    ;;
  esac
  shift
done

${xdebug} && set -x && printVerbose "Enabled command execution trace" 

if ! ${all} && [ -z "${chosenRepos}" ]; then
  printInfo "No packages selected for installation."
  exit 4
fi

# If any of the parameters passed in point to an existing file, then
# the user is attempting to install a port directly from the file system
# rather than a repo
printDebug "Checking input parameters for actual files"
potentials=$(echo "${chosenRepos}" | sed 's/@@/ /g')
for installRepo in ${potentials}; do
  [ -f "${installRepo}" ] && fileinstall=true && break
done

# Sanity check for argument clashes
if ${selectVersion}; then
  if ${all}; then
    printError "Conflicting program arguments, --select cannot be used with --all"
  elif ${fileinstall}; then
    printError "Conflicting program argument, --select cannot be used with local file installations"
  fi
fi
if ${fileinstall} && ${all}; then
  printError "Conflicting program argument, --all cannot be used with local file installations"
fi

if ! ${fileinstall}; then 
  printVerbose "Using potentially remote files; ensuring configured for remote access"
  checkIfConfigLoaded
else
  printVerbose "At least one local file was specified for installation"
fi

mutexReq "zopen" "zopen"
if ${downloadOnly}; then
  downloadDir="${PWD}"
  printDebug "Downloading pax to current directory '${downloadDir}'"
else
  printDebug "Installing to zopen file system: ${ZOPEN_ROOTFS}"
  if [ -z "${ZOPEN_ROOTFS}" ]; then
    printError "Unable to locate zopen file system, \${ZOPEN_ROOTFS} is undefined. Re-source zopen-config and retry command."
  fi
  downloadDir="${ZOPEN_ROOTFS}/var/cache/zopen"
fi

if [ ! -d "${downloadDir}" ]; then
  if ! mkdir -p "${downloadDir}"; then
    printError "Could not create download directory: ${downloadDir}. Check permissions and retry command."
  fi
fi

printDebug "Checking if installing from pax files: ${fileinstall}"
if ! ${fileinstall}; then
  printVerbose "Querying metadata for latest package information"
  getRepos
  grfgRc=$?
  [ 0 -ne ${grfgRc} ] && exit ${grfgRc};
fi

if ${fileinstall}; then
  printDebug "Installing from files as listed in arguments: '${chosenRepos}'"
  printDebug "Fully-qualifying files"
  absoluteFiles=""
  
  for fn in $(echo "${chosenRepos}" | sed 's/@@/ /g'); do
    absoluteFiles="${absoluteFiles} $(toAbsolutePath "${fn}")"
  done
  # generate the install list JSON from the @@-delimited inputs
  installList=$(echo "${absoluteFiles}" \
    | jq --raw-input --arg d "$(pwd -P)" \
    'def make_object($url): {asset:{url: ( "file://" + $d + "/" + $url  )}}; . | split("@@") | map(select(.!="")|make_object(.)) | {"installqueue" :.} ')
else
  if ${all}; then
    # shellcheck disable=SC2034
    doNotInstallDeps=true
    installList=$(jq --raw-output '.release_data| keys[]' "${JSON_CACHE}") 
    installListCount=$(jq --raw-output '.release_data| keys | length' "${JSON_CACHE}") 
    printInfo "- Installing all currently-uninstalled packages"
    printInfo "- Checking installation status for '${installListCount}' packages"
  else
    installList=$(echo "$chosenRepos" | sed "s/@@/ /g")
    validateInstallList "${installList}"
  fi
  if ! generateInstallGraph "${installList}"; then
    printError "Unable to generate install graph"
  fi
fi

if [ 0 -eq "$(echo "${installList}" | jq --raw-output '.installqueue| length')" ]; then
  printInfo "- No packages for install"
else
  if ${verbose}; then 
    printInfo " - The following package(s) will be installed:"
    echo "${installList}" | jq --raw-output '.installqueue | sort| .[] | .portname '
  fi
  if ! processRepoInstallFile; then
    exitrc=1
  else
    printInfo "Installation complete."
  fi
fi
mutexFree "zopen"
exit "${exitrc:-0}"
